# üöÄ ADVANCED ANDROID ROM BUILD PIPELINE v5.0
# High-Performance Distributed Build System with AI/ML Optimization
# 
# üéØ ADVANCED FEATURES:
# - üß† Machine Learning build optimization & predictive analytics
# - üåê Distributed build architecture with intelligent load balancing
# - üê≥ Advanced containerization with multi-stage caching
# - üìä Real-time build streaming & live performance dashboards
# - üîí Automated security scanning & vulnerability detection
# - ‚òÅÔ∏è Intelligent artifact management with CDN distribution
# - ‚ö° Advanced build parallelization with dependency graphs
# - üéØ Cross-platform support with ARM64/x86_64 optimization
# - ü§ñ AI-powered error detection & self-healing (Gemini 2.0)
# - üì° Multi-ROM support with automatic source optimization
# - üì± Real-time notifications (Telegram, Slack, Discord, Teams)
# - üîç Advanced resource monitoring with predictive scaling
# - üöÄ Dynamic pipeline generation with intelligent routing
# - üì¶ Professional artifact management with versioning & signing
# - üåç Global CDN distribution with geographic optimization

env:
  # Build Environment
  TERM: "xterm-256color"
  DEBIAN_FRONTEND: "noninteractive"
  LC_ALL: "C.UTF-8"
  
  # Advanced Pipeline Configuration
  PIPELINE_VERSION: "5.0.0"
  BUILD_TIMEOUT: "21600"  # 6 hours for complex builds
  MAX_PARALLEL_JOBS: "64"  # Scale up to 64 cores for server builds
  
  # üß† ML-Powered Build Optimization
  ENABLE_ML_OPTIMIZATION: "${ENABLE_ML_OPTIMIZATION:-true}"
  ML_MODEL_ENDPOINT: "${ML_MODEL_ENDPOINT:-}"
  PREDICTIVE_SCALING: "${PREDICTIVE_SCALING:-true}"
  BUILD_PATTERN_LEARNING: "${BUILD_PATTERN_LEARNING:-true}"
  
  # üåê Distributed Build Architecture
  ENABLE_DISTRIBUTED_BUILD: "${ENABLE_DISTRIBUTED_BUILD:-true}"
  BUILD_CLUSTER_NODES: "${BUILD_CLUSTER_NODES:-auto}"
  LOAD_BALANCER_ENDPOINT: "${LOAD_BALANCER_ENDPOINT:-}"
  DISTRIBUTED_CCACHE_NODES: "${DISTRIBUTED_CCACHE_NODES:-}"
  
  # üê≥ Advanced Containerization
  ENABLE_CONTAINERIZED_BUILD: "${ENABLE_CONTAINERIZED_BUILD:-true}"
  CONTAINER_REGISTRY: "${CONTAINER_REGISTRY:-ghcr.io}"
  BUILD_CONTAINER_TAG: "${BUILD_CONTAINER_TAG:-latest}"
  MULTI_STAGE_CACHING: "${MULTI_STAGE_CACHING:-true}"
  
  # üìä Real-time Analytics & Streaming
  ENABLE_LIVE_STREAMING: "${ENABLE_LIVE_STREAMING:-true}"
  METRICS_ENDPOINT: "${METRICS_ENDPOINT:-}"
  GRAFANA_DASHBOARD_URL: "${GRAFANA_DASHBOARD_URL:-}"
  PROMETHEUS_PUSHGATEWAY: "${PROMETHEUS_PUSHGATEWAY:-}"
  
  # üîí Security & Compliance
  ENABLE_SECURITY_SCANNING: "${ENABLE_SECURITY_SCANNING:-true}"
  VULNERABILITY_DB_URL: "${VULNERABILITY_DB_URL:-}"
  SIGN_BUILDS: "${SIGN_BUILDS:-true}"
  SECURITY_POLICY_URL: "${SECURITY_POLICY_URL:-}"
  
  # Android Build Configuration
  TARGET_DEVICE: "${TARGET_DEVICE:-lineage_garnet-userdebug}"
  BUILD_VARIANT: "${BUILD_VARIANT:-userdebug}"
  BUILD_TYPE: "${BUILD_TYPE:-UNOFFICIAL}"
  ROM_TYPE: "${ROM_TYPE:-lineage}"
  
  # Dynamic ROM Configuration (set by ROM_TYPE)
  MANIFEST_URL: "${MANIFEST_URL}"
  MANIFEST_BRANCH: "${MANIFEST_BRANCH}"
  
  # Device Tree Configuration
  DEVICE_TREE_URL: "${DEVICE_TREE_URL:-}"
  DEVICE_TREE_BRANCH: "${DEVICE_TREE_BRANCH:-lineage-21.0}"
  KERNEL_SOURCE_URL: "${KERNEL_SOURCE_URL:-}"
  KERNEL_SOURCE_BRANCH: "${KERNEL_SOURCE_BRANCH:-lineage-21.0}"
  VENDOR_TREE_URL: "${VENDOR_TREE_URL:-}"
  VENDOR_TREE_BRANCH: "${VENDOR_TREE_BRANCH:-lineage-21.0}"
  
  # üöÄ High-Performance Server Tuning
  USE_CCACHE: "1"
  CCACHE_SIZE: "${CCACHE_SIZE:-200G}"  # Massive cache for server builds
  CCACHE_COMPRESS: "1"
  CCACHE_COMPRESSLEVEL: "6"
  CCACHE_MAXFILES: "0"
  CCACHE_REMOTE_STORAGE: "${CCACHE_REMOTE_STORAGE:-}"
  BUILD_JOBS: "${BUILD_JOBS:-64}"  # Scale to 64 cores for servers
  SYNC_JOBS: "${SYNC_JOBS:-32}"    # Ultra-aggressive sync
  
  # üß† Intelligent Resource Management
  ENABLE_ADAPTIVE_SCALING: "true"
  ENABLE_PREDICTIVE_SCALING: "true"
  CPU_USAGE_THRESHOLD: "95"  # Higher threshold for server builds
  MEMORY_USAGE_THRESHOLD: "85"
  IO_USAGE_THRESHOLD: "80"
  THERMAL_THRESHOLD: "85"  # CPU temperature monitoring
  
  # ‚ö° Advanced Build Optimization
  SOONG_JAVAC_WRAPPER: "${SOONG_JAVAC_WRAPPER:-ccache}"
  ANDROID_COMPILE_WITH_JACK: "false"
  WITH_DEXPREOPT: "true"
  DEX2OAT_THREADS: "${BUILD_JOBS:-32}"
  ENABLE_NINJA_POOLS: "true"
  NINJA_POOL_DEPTH: "${NINJA_POOL_DEPTH:-2048}"\n  \n  # üñ•Ô∏è Server-Specific Optimizations\n  ENABLE_NUMA_OPTIMIZATION: "${ENABLE_NUMA_OPTIMIZATION:-true}"\n  SERVER_BUILD_MODE: "${SERVER_BUILD_MODE:-true}"\n  HIGH_MEMORY_MODE: "${HIGH_MEMORY_MODE:-true}"\n  FAST_STORAGE_PATH: "${FAST_STORAGE_PATH:-/tmp/android-build}"\n  \n  # üî• Extreme Performance Settings\n  ENABLE_RAMDISK_BUILD: "${ENABLE_RAMDISK_BUILD:-false}"\n  RAMDISK_SIZE: "${RAMDISK_SIZE:-32G}"\n  USE_ZRAM_SWAP: "${USE_ZRAM_SWAP:-true}"
  
  # üîß Cross-Platform Optimization  
  TARGET_ARCH_OPTIMIZATION: "${TARGET_ARCH_OPTIMIZATION:-native}"
  ENABLE_LTO: "${ENABLE_LTO:-true}"  # Link Time Optimization
  ENABLE_PGO: "${ENABLE_PGO:-false}" # Profile Guided Optimization
  CLANG_OPTIMIZATION_LEVEL: "${CLANG_OPTIMIZATION_LEVEL:-O3}"
  
  # Quality Control
  CLEAN_BUILD: "${CLEAN_BUILD:-false}"
  IGNORE_DEVICE_CHECK: "${IGNORE_DEVICE_CHECK:-false}"
  
  # üì° Multi-Platform Notifications
  TELEGRAM_BOT_TOKEN: "${TELEGRAM_BOT_TOKEN:-}"
  TELEGRAM_CHAT_ID: "${TELEGRAM_CHAT_ID:-}"
  ENABLE_TELEGRAM: "${ENABLE_TELEGRAM:-true}"
  SLACK_WEBHOOK_URL: "${SLACK_WEBHOOK_URL:-}"
  DISCORD_WEBHOOK_URL: "${DISCORD_WEBHOOK_URL:-}"
  TEAMS_WEBHOOK_URL: "${TEAMS_WEBHOOK_URL:-}"
  
  # üì¶ Intelligent Package Management
  SKIP_SYSTEM_UPDATE: "${SKIP_SYSTEM_UPDATE:-true}"
  MINIMAL_DEPENDENCIES: "${MINIMAL_DEPENDENCIES:-true}"
  PACKAGE_CACHE_ENABLED: "${PACKAGE_CACHE_ENABLED:-true}"
  APT_CACHE_DIR: "${APT_CACHE_DIR:-/tmp/apt-cache}"
  DEBIAN_FRONTEND: "noninteractive"
  NEEDRESTART_MODE: "a"
  
  # üîç Security & Compliance
  ENABLE_TRIVY_SCAN: "${ENABLE_TRIVY_SCAN:-true}"
  ENABLE_SNYK_SCAN: "${ENABLE_SNYK_SCAN:-false}"
  SECURITY_REPORT_FORMAT: "${SECURITY_REPORT_FORMAT:-json}"
  VULNERABILITY_SEVERITY_THRESHOLD: "${VULNERABILITY_SEVERITY_THRESHOLD:-HIGH}"
  
  
  
  # ü§ñ Advanced AI/ML Systems
  ENABLE_AI_HEALING: "${ENABLE_AI_HEALING:-true}"
  GEMINI_API_KEY: "${GEMINI_API_KEY:-}"
  GEMINI_BASE_URL: "${GEMINI_BASE_URL:-https://generativelanguage.googleapis.com}"
  GEMINI_MODEL: "${GEMINI_MODEL:-gemini-2.0-flash-exp}"
  AI_MAX_RETRIES: "${AI_MAX_RETRIES:-5}"\n  ENABLE_AUTO_FIX: "${ENABLE_AUTO_FIX:-true}"\n  AUTO_FIX_CONFIDENCE_THRESHOLD: "${AUTO_FIX_CONFIDENCE_THRESHOLD:-0.8}"\n  ENABLE_FIX_ROLLBACK: "${ENABLE_FIX_ROLLBACK:-true}"\n  FIX_BACKUP_DIR: "${FIX_BACKUP_DIR:-/tmp/build-backups}"
  
  # üìä ML Build Analytics
  ENABLE_ML_ANALYTICS: "${ENABLE_ML_ANALYTICS:-true}"
  ML_ENDPOINT: "${ML_ENDPOINT:-}"
  ANOMALY_DETECTION: "${ANOMALY_DETECTION:-true}"
  PERFORMANCE_PREDICTION: "${PERFORMANCE_PREDICTION:-true}"
  
  # üéØ Intelligent Build Routing
  ENABLE_SMART_ROUTING: "${ENABLE_SMART_ROUTING:-true}"
  BUILD_AFFINITY_RULES: "${BUILD_AFFINITY_RULES:-cpu-optimized}"
  GEOGRAPHIC_OPTIMIZATION: "${GEOGRAPHIC_OPTIMIZATION:-true}"
  
  # Security
  ENABLE_SIGNING: "${ENABLE_SIGNING:-true}"
  SIGNING_KEY_PATH: "${SIGNING_KEY_PATH:-}"

steps:
  # üåê ADVANCED BUILD ORCHESTRATION
  - label: ":globe_with_meridians: Build Cluster Initialization"
    key: "cluster-init"
    command: |
      set -euo pipefail
      
      echo "üåê Initializing distributed build cluster..."
      
      # ML-powered cluster optimization
      if [ "$$BUILD_CLUSTER_NODES" = "auto" ]; then
        OPTIMAL_NODES=1
        if [ "$$ENABLE_ML_OPTIMIZATION" = "true" ] && [ -n "$$ML_MODEL_ENDPOINT" ]; then
          echo "üß† Consulting ML model for optimal cluster size..."
          OPTIMAL_NODES=$$(curl -s "$$ML_MODEL_ENDPOINT/predict" -d '{"type":"cluster-size"}' | jq -r '.nodes' 2>/dev/null || echo "1")
        fi
        BUILD_CLUSTER_NODES="$$OPTIMAL_NODES"
      fi
      
      # Initialize distributed systems
      if [ "$$ENABLE_DISTRIBUTED_BUILD" = "true" ]; then
        echo "‚ö° Setting up distributed caching and load balancing..."
        buildkite-agent meta-data set "cache-distributed" "true"
      fi
      
      buildkite-agent meta-data set "cluster-size" "$$BUILD_CLUSTER_NODES"
      echo "üöÄ Advanced cluster ready with $$BUILD_CLUSTER_NODES nodes!"
    agents:
      queue: "orchestrator"
    timeout_in_minutes: 10

  - label: ":shield: Pre-Build Validation & Optimization"
    key: "pre-build-validation"
    depends_on: "cluster-init"
    command: |
      set -euo pipefail
      
      echo "üîç Running comprehensive pre-build validation and optimization..."
      
      # Create scripts directory if not exists
      mkdir -p scripts
      
      # Run the pre-build validation script if available
      if [ -f "scripts/pre-build-validation.sh" ]; then
        echo "üîç Running pre-build validation..."
        AUTO_FIX=true bash scripts/pre-build-validation.sh
      else
        echo "‚ö†Ô∏è Pre-build validation script not found, performing basic checks..."
        
        # Basic system checks
        echo "System: $$(uname -a)"
        echo "CPU cores: $$(nproc)"
        echo "RAM: $$(free -h | awk '/^Mem:/ {print $$2}')"
        echo "Disk space: $$(df -h . | awk 'NR==2 {print $$4}')"
        
        # Check essential tools
        for tool in git curl python3 java ccache; do
          if command -v $$tool >/dev/null 2>&1; then
            echo "‚úÖ $$tool is available"
          else
            echo "‚ùå $$tool is missing"
          fi
        done
      fi
      
      # Run build environment optimization if available
      if [ -f "scripts/build-optimization.sh" ]; then
        echo "‚ö° Running build optimization..."
        bash scripts/build-optimization.sh
      else
        echo "‚ö†Ô∏è Build optimization script not found, applying basic optimizations..."
        
        # Basic optimizations
        export USE_CCACHE=1
        export CCACHE_DIR="$$HOME/.ccache"
        mkdir -p "$$CCACHE_DIR"
        
        if command -v ccache >/dev/null 2>&1; then
          ccache -M 30G >/dev/null 2>&1 || true
          echo "‚úÖ ccache configured with 30GB limit"
        fi
        
        # Set build job optimization
        CORES=$$(nproc)
        export BUILD_JOBS=$$CORES
        echo "‚úÖ Build jobs set to $$CORES"
        buildkite-agent meta-data set "build-jobs" "$$BUILD_JOBS"
      fi
      
      echo "‚úÖ Pre-build validation and optimization completed"
    agents:
      queue: "default"
    timeout_in_minutes: 15
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    artifact_paths:
      - "*-report.txt"

  - wait: ~
  - label: ":mag: System Diagnostics & ROM Selection"
    key: "system-diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîç Running comprehensive system diagnostics..."
      
      # ===============================================
      # UTILITY FUNCTIONS
      # ===============================================
      
      # Telegram notification function
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      # üß† ADVANCED AI/ML HEALING SYSTEM
      ai_heal_error() {
        local error_message="$$1"
        local step_name="$$2"
        local attempt="$$3"
        
        if [ "$$ENABLE_AI_HEALING" != "true" ] || [ -z "$$GEMINI_API_KEY" ] || [ "$$attempt" -gt "$$AI_MAX_RETRIES" ]; then
          return 1
        fi
        
        echo "ü§ñ AI Healing: Analyzing error with Gemini $$GEMINI_MODEL..."
        
        # Prepare the prompt for Gemini
        local prompt="You are an expert Android ROM build engineer. Analyze this build error and provide a specific fix:
        
        Step: $$step_name
        Error: $$error_message
        
        Provide a concise bash command or solution to fix this specific error. Focus on practical fixes for Android ROM building on Ubuntu/Debian systems."
        
        # Call Gemini API
        local response=$$(curl -s -X POST "$$GEMINI_BASE_URL/v1beta/models/$$GEMINI_MODEL:generateContent" \
          -H "Content-Type: application/json" \
          -H "x-goog-api-key: $$GEMINI_API_KEY" \
          -d "{
            \"contents\": [{
              \"parts\": [{
                \"text\": \"$$prompt\"
              }]
            }]
          }" 2>/dev/null)
        
        if [ $$? -eq 0 ] && [ -n "$$response" ]; then
          local suggestion=$$(echo "$$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', 'No suggestion'))" 2>/dev/null)
          
          if [ -n "$$suggestion" ] && [ "$$suggestion" != "No suggestion" ]; then
            echo "ü§ñ AI Suggestion: $$suggestion"
            send_telegram "ü§ñ *AI Healing Activated*%0AStep: $$step_name%0AError: $$(echo "$$error_message" | head -c 200)...%0A%0Aüí° *AI Suggestion:*%0A$$suggestion"
            return 0
          fi
        fi
        
        return 1
      }
      
      # ROM selection function
      select_rom_manifest() {
        echo "üì± ROM Selection: $$ROM_TYPE"
        
        case "$$ROM_TYPE" in
          lineage)
            export MANIFEST_URL="$$LINEAGE_MANIFEST_URL"
            export MANIFEST_BRANCH="$$LINEAGE_MANIFEST_BRANCH"
            ;;
          crdroid)
            export MANIFEST_URL="$$CRDROID_MANIFEST_URL"
            export MANIFEST_BRANCH="$$CRDROID_MANIFEST_BRANCH"
            ;;
          pixel)
            export MANIFEST_URL="$$PIXEL_MANIFEST_URL"
            export MANIFEST_BRANCH="$$PIXEL_MANIFEST_BRANCH"
            ;;
          aosp)
            export MANIFEST_URL="$$AOSP_MANIFEST_URL"
            export MANIFEST_BRANCH="$$AOSP_MANIFEST_BRANCH"
            ;;
          evolution)
            export MANIFEST_URL="$$EVOLUTION_MANIFEST_URL"
            export MANIFEST_BRANCH="$$EVOLUTION_MANIFEST_BRANCH"
            ;;
          *)
            echo "‚ùå Unsupported ROM type: $$ROM_TYPE"
            echo "Supported ROMs: lineage, crdroid, pixel, aosp, evolution"
            exit 1
            ;;
        esac
        
        echo "‚úÖ Selected ROM: $$ROM_TYPE"
        echo "üì¶ Manifest: $$MANIFEST_URL"
        echo "üåø Branch: $$MANIFEST_BRANCH"
        
        # Send initial Telegram notification
        send_telegram "üöÄ *Android ROM Build Started*%0A%0Aüì± *Device:* Redmi Note 13 Pro 5G (garnet)%0AüéØ *ROM:* $$ROM_TYPE%0Aüåø *Branch:* $$MANIFEST_BRANCH%0Aüíª *Build ID:* #$$BUILDKITE_BUILD_NUMBER%0A%0A‚è±Ô∏è Started: $$(date '+%Y-%m-%d %H:%M:%S')"
      }
      
      # Select ROM configuration
      select_rom_manifest
      
      # Create logs directory
      mkdir -p logs
      
      # System information with proper variable escaping
      {
        echo "=== SYSTEM INFORMATION ==="
        uname -a
        lsb_release -a 2>/dev/null || cat /etc/os-release
        
        echo -e "\n=== HARDWARE SPECS ==="
        echo "CPU Cores: $$(nproc)"
        echo "CPU Info: $$(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
        echo "Total RAM: $$(free -h | awk '/^Mem:/ {print $$2}')"
        echo "Available RAM: $$(free -h | awk '/^Mem:/ {print $$7}')"
        
        echo -e "\n=== DISK SPACE ==="
        df -h / /tmp 2>/dev/null || true
        echo "Available Space: $$(df -h / | awk 'NR==2 {print $$4}') (on root filesystem)"
        
        echo -e "\n=== NETWORK ==="
        curl -s --max-time 10 https://httpbin.org/ip || echo "Network test failed"
        
        echo -e "\n=== BUILD TOOLS ==="
        java -version 2>&1 || echo "Java not found"
        python3 --version 2>&1 || echo "Python3 not found"
        git --version 2>&1 || echo "Git not found"
        
      } | tee logs/system-diagnostics.log
      
      # Validate minimum requirements with proper variable handling
      echo "üß™ Validating advanced build requirements..."
      
      CORES=$$(nproc)
      RAM_GB=$$(free -g | awk '/^Mem:/ {print $$2}')
      DISK_GB=$$(df -BG / | awk 'NR==2 {gsub("G",""); print int($$4)}')
      
      # Fallback detection if awk fails
      if [ -z "$$RAM_GB" ] || [ "$$RAM_GB" = "0" ]; then
        RAM_GB=$$(free -m | awk '/^Mem:/ {printf "%.0f", $$2/1024}')
      fi
      
      if [ -z "$$DISK_GB" ] || [ "$$DISK_GB" = "0" ]; then
        DISK_GB=$$(df -BG / | tail -1 | awk '{gsub("G",""); print int($$4)}')
      fi
      
      echo "üìä Resource Summary:"
      echo "  CPU Cores: $$CORES (minimum: 8)"
      echo "  RAM: $${RAM_GB}GB (no minimum required)"
      echo "  Disk Space: $${DISK_GB}GB (minimum: 100GB)"
      
      # Generate performance baseline
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"cpu_cores\": $$CORES,"
        echo "  \"ram_gb\": $$RAM_GB,"
        echo "  \"disk_gb\": $$DISK_GB,"
        echo "  \"cpu_model\": \"$$(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)\","
        echo "  \"kernel\": \"$$(uname -r)\","
        echo "  \"os\": \"$$(lsb_release -ds 2>/dev/null || cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '\"')\""
        echo "}"
      } > logs/hardware-report.json
      
      # Check requirements and fail if insufficient
      ERRORS=0
      
      if [ "$$CORES" -lt 8 ]; then
        echo "‚ùå Insufficient CPU cores: $$CORES < 8"
        ERRORS=$$((ERRORS + 1))
      fi
      
      # RAM check removed - no minimum requirement
      echo "‚ÑπÔ∏è RAM: $${RAM_GB}GB detected (proceeding regardless of amount)"
      
      if [ "$$DISK_GB" -lt 100 ]; then
        echo "‚ùå Insufficient disk space: $${DISK_GB}GB < 100GB"
        ERRORS=$$((ERRORS + 1))
      fi
      
      if [ "$$ERRORS" -gt 0 ]; then
        echo "üí• $$ERRORS critical errors found! Build cannot proceed."
        echo "Please upgrade your build infrastructure."
        exit 1
      fi
      
      echo "‚úÖ All advanced requirements satisfied!"
      
      # Upload diagnostics
      buildkite-agent artifact upload "logs/system-diagnostics.log"
      buildkite-agent artifact upload "logs/hardware-report.json"
    agents:
      queue: "default"
    timeout_in_minutes: 10
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    artifact_paths:
      - "logs/system-diagnostics.log"
      - "logs/hardware-report.json"

  - label: ":package: Dependency Management"
    key: "dependency-management"
    depends_on: "system-diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîß Intelligent Android build dependency management..."
      
      # Import utility functions from previous step
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      # Intelligent package verification function
      check_package_needed() {
        local package="$$1"
        local reason="$$2"
        
        # Check if package is already installed
        if dpkg-query -W -f='$${Status}' "$$package" 2>/dev/null | grep -q "ok installed"; then
          echo "‚úÖ $$package already installed ($$reason)"
          return 1  # Don't install
        fi
        
        # Check if package exists in repositories
        if ! apt-cache show "$$package" >/dev/null 2>&1; then
          echo "‚ùå Package $$package not found in repositories"
          return 1  # Don't install
        fi
        
        echo "üì¶ Need to install: $$package ($$reason)"
        return 0  # Install needed
      }
      
      # Smart dependency detection
      detect_needed_packages() {
        local needed_packages=()
        
        # Core build tools - always needed
        check_package_needed "git" "version control" && needed_packages+=("git")
        check_package_needed "curl" "network operations" && needed_packages+=("curl")
        check_package_needed "wget" "downloads" && needed_packages+=("wget")
        check_package_needed "python3" "build scripts" && needed_packages+=("python3")
        check_package_needed "python3-pip" "python packages" && needed_packages+=("python3-pip")
        check_package_needed "build-essential" "compilation tools" && needed_packages+=("build-essential")
        
        # Java - detect which version is needed
        if ! java -version >/dev/null 2>&1; then
          check_package_needed "openjdk-8-jdk" "Android 8-10 builds" && needed_packages+=("openjdk-8-jdk")
          check_package_needed "openjdk-11-jdk" "Android 11+ builds" && needed_packages+=("openjdk-11-jdk")
        fi
        
        # Android-specific libraries - only if needed
        check_package_needed "libncurses5" "terminal support" && needed_packages+=("libncurses5")
        check_package_needed "lib32ncurses5-dev" "32-bit ncurses" && needed_packages+=("lib32ncurses5-dev")
        check_package_needed "libxml2-utils" "XML processing" && needed_packages+=("libxml2-utils")
        check_package_needed "xsltproc" "XSLT processing" && needed_packages+=("xsltproc")
        
        # Compression tools
        check_package_needed "zip" "archive creation" && needed_packages+=("zip")
        check_package_needed "unzip" "archive extraction" && needed_packages+=("unzip")
        check_package_needed "zlib1g-dev" "compression library" && needed_packages+=("zlib1g-dev")
        
        # Build optimization
        check_package_needed "ccache" "compilation caching" && needed_packages+=("ccache")
        check_package_needed "schedtool" "process scheduling" && needed_packages+=("schedtool")
        check_package_needed "bc" "basic calculator" && needed_packages+=("bc")
        check_package_needed "bison" "parser generator" && needed_packages+=("bison")
        check_package_needed "flex" "lexical analyzer" && needed_packages+=("flex")
        
        # Multi-lib support - only if building for multiple architectures
        if [ "$$TARGET_ARCH" = "arm64" ] && [ -n "$$TARGET_2ND_ARCH" ]; then
          check_package_needed "g++-multilib" "multi-arch support" && needed_packages+=("g++-multilib")
          check_package_needed "gcc-multilib" "multi-arch gcc" && needed_packages+=("gcc-multilib")
        fi
        
        echo "$${needed_packages[@]}"
      }
      
      # Send status update
      send_telegram "‚öôÔ∏è *Installing Dependencies*%0A%0Aüì¶ Installing Android build tools and dependencies..."
      
      # Create installation log
      mkdir -p logs
      INSTALL_LOG="logs/dependency-install.log"
      
      # Function for intelligent retry logic
      retry_command() {
        local max_attempts=5
        local delay=10
        local command="$$1"
        local attempt=1
        
        until [ $$attempt -gt $$max_attempts ]; do
          echo "üîÑ Attempt $$attempt/$$max_attempts: $$command"
          if eval "$$command"; then
            echo "‚úÖ Command succeeded: $$command"
            return 0
          else
            echo "‚ùå Command failed, retrying in $${delay}s..."
            sleep $$delay
            delay=$$((delay * 2))
            attempt=$$((attempt + 1))
          fi
        done
        
        echo "üí• Command failed after $$max_attempts attempts: $$command"
        return 1
      }
      
      # Log installation start
      {
        echo "=== ADVANCED DEPENDENCY INSTALLATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Host: $$(hostname)"
        echo "User: $$(whoami)"
        echo "Working Directory: $$(pwd)"
        echo ""
      } > "$$INSTALL_LOG"
      
      # Validate OS compatibility
      if ! command -v apt-get &> /dev/null; then
        echo "‚ùå This pipeline requires Ubuntu/Debian with apt-get"
        exit 1
      fi
      
      # Determine if we need sudo (check if running as root)
      if [ "$$(id -u)" = "0" ]; then
        SUDO_CMD=""
        echo "‚ÑπÔ∏è Running as root - no sudo needed"
      elif command -v sudo &> /dev/null; then
        SUDO_CMD="sudo"
        echo "‚ÑπÔ∏è Running as user - using sudo"
      else
        echo "‚ùå Not root and sudo not available. Cannot install packages."
        exit 1
      fi
      
      # Skip system update if configured
      if [ "$$SKIP_SYSTEM_UPDATE" = "true" ]; then
        echo "‚è© Skipping system update (SKIP_SYSTEM_UPDATE=true)"
        echo "‚ÑπÔ∏è Only updating package lists..."
        retry_command "$$SUDO_CMD apt-get update -qq" 2>&1 | tee -a "$$INSTALL_LOG"
      else
        echo "üì¶ Updating package repositories and system..."
        retry_command "$$SUDO_CMD apt-get update -qq" 2>&1 | tee -a "$$INSTALL_LOG"
        retry_command "$$SUDO_CMD apt-get upgrade -y" 2>&1 | tee -a "$$INSTALL_LOG"
      fi
      
      # Intelligent dependency installation
      echo "üß† Detecting required packages..."
      NEEDED_PACKAGES=($(detect_needed_packages))
      
      if [ $${#NEEDED_PACKAGES[@]} -eq 0 ]; then
        echo "‚úÖ All required packages already installed!"
      else
        echo "üì¶ Installing $${#NEEDED_PACKAGES[@]} required packages: $${NEEDED_PACKAGES[*]}"
        
        # Setup package cache if enabled
        if [ "$$PACKAGE_CACHE_ENABLED" = "true" ]; then
          echo "üóÑÔ∏è Setting up package cache..."
          mkdir -p "$$APT_CACHE_DIR"
          echo "Dir::Cache::Archives \"$$APT_CACHE_DIR\";" | $$SUDO_CMD tee /etc/apt/apt.conf.d/01buildkite-cache
        fi
        
        # Install only needed packages
        if [ "$${#NEEDED_PACKAGES[@]}" -gt 0 ]; then
          retry_command "$$SUDO_CMD apt-get install -y --no-install-recommends $${NEEDED_PACKAGES[*]}" 2>&1 | tee -a "$$INSTALL_LOG"
        fi
        
        # Clean up if minimal dependencies is enabled
        if [ "$$MINIMAL_DEPENDENCIES" = "true" ]; then
          echo "üßπ Cleaning unnecessary packages..."
          $$SUDO_CMD apt-get autoremove -y 2>&1 | tee -a "$$INSTALL_LOG"
          $$SUDO_CMD apt-get autoclean 2>&1 | tee -a "$$INSTALL_LOG"
        fi
      fi
      
      # Configure Java environment for Android builds
      echo "‚òï Configuring Java environment..."
      export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
      export PATH=$$JAVA_HOME/bin:$$PATH
      
      # Install repo tool with verification
      echo "üîÑ Installing Google repo tool..."
      REPO_URL="https://storage.googleapis.com/git-repo-downloads/repo"
      
      retry_command "curl -o /tmp/repo '$$REPO_URL'" 2>&1 | tee -a "$$INSTALL_LOG"
      
      # Verify repo download
      if [ ! -f /tmp/repo ] || [ ! -s /tmp/repo ]; then
        echo "‚ùå Failed to download repo tool"
        exit 1
      fi
      
      $$SUDO_CMD mv /tmp/repo /usr/local/bin/repo
      $$SUDO_CMD chmod a+x /usr/local/bin/repo
      
      # Verify repo installation and fix PATH if needed
      echo "üîç Verifying repo tool installation..."
      export PATH="/usr/local/bin:$$PATH"
      
      # Test repo tool
      if repo --version >/dev/null 2>&1; then
        REPO_VERSION=$$(repo --version 2>/dev/null | head -1)
        echo "‚úÖ Repo tool installed: $$REPO_VERSION"
      elif python3 /usr/local/bin/repo --version >/dev/null 2>&1; then
        echo "‚úÖ Repo tool installed: $$(python3 /usr/local/bin/repo --version 2>/dev/null | head -1)"
      else
        echo "‚ùå Repo tool installation failed"
        echo "Checking if repo file exists: $$(ls -la /usr/local/bin/repo 2>/dev/null || echo 'not found')"
        exit 1
      fi
      
      # Advanced ccache configuration with intelligent caching
      echo "üöÄ Configuring advanced ccache with intelligent caching..."
      export USE_CCACHE=1
      export CCACHE_DIR="$$HOME/.ccache"
      mkdir -p "$$CCACHE_DIR"
      
      # Clean CCACHE_SIZE value (remove any comments)
      CLEAN_CCACHE_SIZE=$$(echo "$${CCACHE_SIZE:-30G}" | awk '{print $$1}' | tr -d '"')
      echo "Setting ccache size to: $$CLEAN_CCACHE_SIZE"
      ccache -M "$$CLEAN_CCACHE_SIZE"
      
      # Advanced ccache optimizations
      export CCACHE_COMPRESS=1
      export CCACHE_COMPRESSLEVEL=6
      export CCACHE_MAXFILES=0
      export CCACHE_SLOPPINESS="file_macro,locale,time_macros"
      export CCACHE_BASEDIR="$$(pwd)"
      
      # Enable remote ccache if configured
      if [ -n "$$CCACHE_REMOTE_STORAGE" ]; then
        echo "üåê Configuring remote ccache storage: $$CCACHE_REMOTE_STORAGE"
        export CCACHE_REMOTE_STORAGE="$$CCACHE_REMOTE_STORAGE"
        export CCACHE_REMOTE_ONLY=false
      fi
      
      # Initialize ccache with optimized settings
      ccache -z  # Zero statistics
      ccache -s  # Show statistics
      
      # Setup build cache directories
      echo "üì¶ Setting up build cache directories..."
      mkdir -p "$$HOME/.gradle/caches"
      mkdir -p "$$HOME/.android/cache"
      
      # Configure gradle caching
      if [ ! -f "$$HOME/.gradle/gradle.properties" ]; then
        cat > "$$HOME/.gradle/gradle.properties" << 'EOF'
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
org.gradle.configureondemand=true
org.gradle.jvmargs=-Xmx4g -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true
EOF
      fi
      
      # Configure git for repo operations
      echo "üîß Configuring git environment..."
      git config --global user.email "$${GIT_EMAIL:-android-builder@buildkite.local}"
      git config --global user.name "$${GIT_NAME:-Buildkite Android Builder}"
      git config --global color.ui auto
      git config --global init.defaultBranch master
      
      # Generate installation verification report
      {
        echo "=== INSTALLATION VERIFICATION ==="
        echo "Java: $$(java -version 2>&1 | head -1)"
        echo "Python: $$(python3 --version)"
        echo "Git: $$(git --version)"
        echo "Repo: $$(repo --version | head -1)"
        echo "Make: $$(make --version | head -1)"
        echo "GCC: $$(gcc --version | head -1)"
        echo "Ccache: $$(ccache --version | head -1)"
        echo "Ccache stats: $$(ccache -s | grep 'cache size')"
        echo "Completed: $$(date -Iseconds)"
      } | tee -a "$$INSTALL_LOG"
      
      # Create verification report in JSON
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"java_version\": \"$$(java -version 2>&1 | head -1 | tr -d '\"')\","
        echo "  \"python_version\": \"$$(python3 --version)\","
        echo "  \"git_version\": \"$$(git --version)\","
        echo "  \"repo_version\": \"$$(repo --version | head -1)\","
        echo "  \"ccache_size\": \"$$CCACHE_SIZE\","
        echo "  \"status\": \"success\""
        echo "}"
      } > logs/package-verification.json
      
      echo "‚úÖ All advanced dependencies installed and verified!"
      
      # Upload logs
      buildkite-agent artifact upload "$$INSTALL_LOG"
      buildkite-agent artifact upload "logs/package-verification.json"
    agents:
      queue: "default"
    timeout_in_minutes: 45
    retry:
      automatic:
        - exit_status: "*"
          limit: 3
    artifact_paths:
      - "logs/dependency-install.log"
      - "logs/package-verification.json"


  - label: ":octocat: Repository Initialization"
    key: "repo-init"
    depends_on: "dependency-management"
    command: |
      set -euo pipefail
      
      echo "üöÄ Android repository initialization..."
      
      # Import utility functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      # Send status update
      send_telegram "üì¶ *Repository Initialization*%0A%0Aüîß Setting up Android source repository..."
      
      # Create workspace and logs
      mkdir -p android-workspace logs
      cd android-workspace
      
      # Initialize timing and monitoring
      START_TIME=$$(date +%s)
      INIT_LOG="../logs/repo-init.log"
      
      {
        echo "=== ANDROID REPOSITORY INITIALIZATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Manifest URL: $$MANIFEST_URL"
        echo "Manifest Branch: $$MANIFEST_BRANCH"
        echo "Target Device: $$TARGET_DEVICE"
        echo ""
      } > "$$INIT_LOG"
      
      # Validate manifest URL accessibility
      echo "üîç Validating manifest repository..."
      
      # Test git repository accessibility (more reliable than curl --head)
      if git ls-remote --heads --exit-code "$$MANIFEST_URL" >/dev/null 2>&1; then
        echo "‚úÖ Manifest repository accessible via git"
      elif curl -s --max-time 30 "$$MANIFEST_URL" >/dev/null 2>&1; then
        echo "‚úÖ Manifest repository accessible via HTTP"
      else
        echo "‚ö†Ô∏è Manifest URL validation failed, but proceeding anyway..."
        echo "URL: $$MANIFEST_URL"
        echo "This might be a network issue or temporary unavailability"
      fi
      
      # Initialize repo with comprehensive error handling
      echo "üìã Initializing Android repository..."
      
      # Function for repo operations with retry
      repo_operation() {
        local operation="$$1"
        local max_attempts=3
        local attempt=1
        
        while [ $$attempt -le $$max_attempts ]; do
          echo "üîÑ Repo $$operation attempt $$attempt/$$max_attempts"
          
          if [ "$$operation" = "init" ]; then
            if repo init -u "$$MANIFEST_URL" -b "$$MANIFEST_BRANCH" --depth=1 2>&1 | tee -a "$$INIT_LOG"; then
              echo "‚úÖ Repo initialization successful"
              return 0
            fi
          fi
          
          echo "‚ùå Repo $$operation failed, attempt $$attempt/$$max_attempts"
          
          if [ $$attempt -lt $$max_attempts ]; then
            echo "üßπ Cleaning up for retry..."
            rm -rf .repo
            sleep $$((attempt * 10))
          fi
          
          attempt=$$((attempt + 1))
        done
        
        echo "üí• Repo $$operation failed after $$max_attempts attempts"
        return 1
      }
      
      # Execute repo initialization with retry
      if ! repo_operation "init"; then
        echo "üí• Repository initialization failed!"
        exit 1
      fi
      
      # Validate repo initialization
      if [ ! -d .repo ]; then
        echo "‚ùå Repository initialization incomplete - .repo directory missing"
        exit 1
      fi
      
      # Generate repository analysis
      {
        echo "=== REPOSITORY ANALYSIS ==="
        echo "Repo version: $$(repo --version | head -1)"
        echo "Manifest projects: $$(repo list | wc -l)"
        echo "Repo directory size: $$(du -sh .repo | cut -f1)"
        echo "Initialization time: $$(($(date +%s) - START_TIME))s"
      } | tee -a "$$INIT_LOG"
      
      # Create repository state report
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"manifest_url\": \"$$MANIFEST_URL\","
        echo "  \"manifest_branch\": \"$$MANIFEST_BRANCH\","
        echo "  \"repo_version\": \"$$(repo --version | head -1)\","
        echo "  \"project_count\": $$(repo list | wc -l),"
        echo "  \"initialization_time_seconds\": $$(($(date +%s) - START_TIME)),"
        echo "  \"status\": \"initialized\""
        echo "}"
      } > ../logs/manifest-info.json
      
      echo "‚úÖ Android repository initialized successfully!"
      
      # Upload artifacts from parent directory
      cd ..
      buildkite-agent artifact upload "$$INIT_LOG"
      buildkite-agent artifact upload "logs/manifest-info.json"
    agents:
      queue: "default"
    timeout_in_minutes: 30
    retry:
      automatic:
        - exit_status: "*"
          limit: 3
    artifact_paths:
      - "logs/repo-init.log"
      - "logs/manifest-info.json"
    concurrency_group: "repo-init"
    concurrency: 1

  - label: ":arrows_counterclockwise: Source Synchronization"
    key: "source-sync"
    depends_on: "repo-init"
    command: |
      set -euo pipefail
      
      echo "üîÑ Android source synchronization..."
      
      # Import utility functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      # Send status update
      send_telegram "üîÑ *Source Synchronization*%0A%0Aüì° Downloading $$ROM_TYPE source code and device trees..."
      
      # Ensure workspace directory exists (create if missing)
      if [ ! -d android-workspace ]; then
        echo "‚ö†Ô∏è Android workspace not found, creating it..."
        mkdir -p android-workspace
        echo "‚ÑπÔ∏è Note: This suggests the repository initialization step may not have completed"
      fi
      
      cd android-workspace
      
      # Check if repo is initialized, initialize if needed
      if [ ! -d .repo ]; then
        echo "‚ö†Ô∏è Repository not initialized, initializing now..."
        if ! repo init -u "$$MANIFEST_URL" -b "$$MANIFEST_BRANCH" --depth=1; then
          echo "‚ùå Failed to initialize repository"
          exit 1
        fi
        echo "‚úÖ Repository initialized"
      else
        echo "‚úÖ Repository already initialized"
      fi
      
      # Initialize sync monitoring
      START_TIME=$$(date +%s)
      mkdir -p ../logs
      SYNC_LOG="../logs/sync-$$(date +%Y%m%d-%H%M%S).log"
      
      {
        echo "=== ADVANCED SOURCE SYNCHRONIZATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Sync Jobs: $${SYNC_JOBS:-8}"
        echo "Working Directory: $$(pwd)"
        echo ""
      } > "$$SYNC_LOG"
      
      # Dynamic resource scaling and optimization
      CORES=$$(nproc)
      TOTAL_RAM_GB=$$(free -g | awk '/^Mem:/ {print $2}')
      AVAILABLE_RAM_GB=$$(free -g | awk '/^Mem:/ {print $7}')
      
      echo "üîß System Resources: $$CORES cores, $${TOTAL_RAM_GB}GB total RAM, $${AVAILABLE_RAM_GB}GB available"
      
      # Advanced sync job calculation with memory consideration
      if [ -z "$$SYNC_JOBS" ]; then
        # Base calculation on CPU cores
        if [ "$$CORES" -ge 16 ]; then
          SYNC_JOBS=12
        elif [ "$$CORES" -ge 12 ]; then
          SYNC_JOBS=8
        elif [ "$$CORES" -ge 8 ]; then
          SYNC_JOBS=6
        elif [ "$$CORES" -ge 4 ]; then
          SYNC_JOBS=4
        else
          SYNC_JOBS=2
        fi
        
        # Adjust based on available memory (reduce if low memory)
        if [ "$$AVAILABLE_RAM_GB" -lt 4 ]; then
          SYNC_JOBS=$$((SYNC_JOBS / 2))
          echo "‚ö†Ô∏è Low memory detected, reducing sync jobs to $$SYNC_JOBS"
        fi
        
        echo "üîß Auto-detected sync jobs: $$SYNC_JOBS ($$CORES cores, $${AVAILABLE_RAM_GB}GB RAM)"
      fi
      
      # Dynamic build job optimization for later use
      if [ -z "$$BUILD_JOBS" ]; then
        # Calculate optimal build jobs based on system resources
        BUILD_JOBS=$$CORES
        
        # Memory-based adjustment (need ~2GB per job for Android builds)
        MAX_JOBS_BY_MEMORY=$$((AVAILABLE_RAM_GB / 2))
        if [ "$$BUILD_JOBS" -gt "$$MAX_JOBS_BY_MEMORY" ]; then
          BUILD_JOBS=$$MAX_JOBS_BY_MEMORY
          echo "üîß Memory-limited build jobs: $$BUILD_JOBS (was $$CORES)"
        fi
        
        # Ensure minimum of 1 job
        if [ "$$BUILD_JOBS" -lt 1 ]; then
          BUILD_JOBS=1
        fi
        
        echo "üîß Optimized build jobs: $$BUILD_JOBS"
        buildkite-agent meta-data set "optimized-build-jobs" "$$BUILD_JOBS"
      fi
      
      # Enhanced sync function with advanced monitoring and recovery
      advanced_sync() {
        local attempt=1
        local max_attempts=5
        local base_delay=60
        local sync_start_time=$$(date +%s)
        
        # Pre-sync validation
        echo "üîç Pre-sync validation..."
        if ! curl -s --connect-timeout 10 "$$MANIFEST_URL" >/dev/null; then
          echo "‚ùå Cannot reach manifest URL: $$MANIFEST_URL"
          return 1
        fi
        echo "‚úÖ Manifest URL accessible"
        
        while [ $$attempt -le $$max_attempts ]; do
          echo "üîÑ Sync attempt $$attempt/$$max_attempts (using $$SYNC_JOBS jobs)"
          
          # Start sync with comprehensive monitoring
          {
            echo "=== SYNC ATTEMPT $$attempt ==="
            echo "Started: $$(date -Iseconds)"
            echo "Command: repo sync -c -j$$SYNC_JOBS --force-sync --no-tags --no-clone-bundle --optimized-fetch --prune"
          } | tee -a "$$SYNC_LOG"
          
          # Execute sync with timeout and monitoring
          if timeout 7200 repo sync -c -j"$$SYNC_JOBS" --force-sync --no-tags --no-clone-bundle --optimized-fetch --prune 2>&1 | tee -a "$$SYNC_LOG"; then
            echo "‚úÖ Source synchronization completed successfully!"
            
            # Generate sync completion report
            {
              echo "=== SYNC COMPLETION REPORT ==="
              echo "Completed: $$(date -Iseconds)"
              echo "Total sync time: $$(($(date +%s) - START_TIME))s"
              echo "Projects synced: $$(repo list | wc -l)"
              echo "Repository size: $$(du -sh . | cut -f1)"
            } | tee -a "$$SYNC_LOG"
            
            return 0
          else
            SYNC_EXIT_CODE=$$?
            echo "‚ùå Sync attempt $$attempt failed with exit code: $$SYNC_EXIT_CODE"
            
            # Analyze failure and attempt recovery
            if [ $$SYNC_EXIT_CODE -eq 124 ]; then
              echo "‚è∞ Sync timed out - may need to reduce concurrent jobs"
              if [ "$$SYNC_JOBS" -gt 2 ]; then
                SYNC_JOBS=$$((SYNC_JOBS / 2))
                echo "üîß Reducing sync jobs to $$SYNC_JOBS for retry"
              fi
            fi
            
            # Clean up corrupted state if needed
            echo "üßπ Cleaning up potential corruption..."
            repo forall -c 'git reset --hard HEAD; git clean -fd' 2>/dev/null || true
            
            if [ $$attempt -lt $$max_attempts ]; then
              delay=$$((base_delay * attempt))
              echo "‚è≥ Waiting $${delay}s before retry..."
              sleep $$delay
            fi
          fi
          
          attempt=$$((attempt + 1))
        done
        
        echo "üí• All sync attempts failed!"
        return 1
      }
      
      # Execute advanced sync
      if ! advanced_sync; then
        echo "üí• Source synchronization failed after all retry attempts!"
        exit 1
      fi
      
      # Verify sync integrity
      echo "üîç Verifying synchronization integrity..."
      
      REPO_STATUS=$$(repo status 2>/dev/null | wc -l)
      if [ "$$REPO_STATUS" -gt 0 ]; then
        echo "‚ö†Ô∏è Warning: $$REPO_STATUS projects have uncommitted changes"
        repo status | head -20 | tee -a "$$SYNC_LOG"
      else
        echo "‚úÖ All projects are clean"
      fi
      
      # Generate comprehensive sync analytics
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"sync_duration_seconds\": $$(($(date +%s) - START_TIME)),"
        echo "  \"sync_jobs_used\": $$SYNC_JOBS,"
        echo "  \"total_projects\": $$(repo list | wc -l),"
        echo "  \"repository_size_mb\": $$(du -sm . | cut -f1),"
        echo "  \"projects_with_changes\": $$REPO_STATUS,"
        echo "  \"status\": \"completed\""
        echo "}"
      } > ../logs/sync-analytics.json
      
      echo "‚úÖ Advanced source synchronization completed!"
      
      # Clone device-specific trees if specified
      echo "üå≥ Cloning device trees and vendor blobs..."
      
      if [ -n "$$DEVICE_TREE_URL" ]; then
        echo "üì± Cloning device tree from: $$DEVICE_TREE_URL"
        # Extract device name from TARGET_DEVICE (lineage_garnet-userdebug -> garnet)
        DEVICE_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        
        # Determine manufacturer based on device name
        case "$$DEVICE_NAME" in
          garnet)
            DEVICE_MANUFACTURER="xiaomi"
            ;;
          *)
            # Try to extract from device tree URL as fallback
            DEVICE_MANUFACTURER="$$(echo "$$DEVICE_TREE_URL" | sed -n 's/.*android_device_\([^_]*\)_.*/\1/p')"
            if [ -z "$$DEVICE_MANUFACTURER" ]; then
              DEVICE_MANUFACTURER="unknown"
            fi
            ;;
        esac
        
        echo "üì± Device: $$DEVICE_MANUFACTURER/$$DEVICE_NAME"
        mkdir -p "device/$$DEVICE_MANUFACTURER"
        if ! git clone "$$DEVICE_TREE_URL" -b "$$DEVICE_TREE_BRANCH" "device/$$DEVICE_MANUFACTURER/$$DEVICE_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone device tree, continuing without it"
        else
          echo "‚úÖ Device tree cloned to device/$$DEVICE_MANUFACTURER/$$DEVICE_NAME"
        fi
      fi
      
      if [ -n "$$KERNEL_SOURCE_URL" ]; then
        echo "üîß Cloning kernel source from: $$KERNEL_SOURCE_URL"
        # Use same manufacturer as device
        KERNEL_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        case "$$KERNEL_NAME" in
          garnet)
            KERNEL_MANUFACTURER="xiaomi"
            ;;
          *)
            KERNEL_MANUFACTURER="$$(echo "$$KERNEL_SOURCE_URL" | sed -n 's/.*android_kernel_\([^_]*\)_.*/\1/p')"
            if [ -z "$$KERNEL_MANUFACTURER" ]; then
              KERNEL_MANUFACTURER="unknown"
            fi
            ;;
        esac
        
        echo "üîß Kernel: $$KERNEL_MANUFACTURER/$$KERNEL_NAME"
        mkdir -p "kernel/$$KERNEL_MANUFACTURER"
        if ! git clone "$$KERNEL_SOURCE_URL" -b "$$KERNEL_SOURCE_BRANCH" "kernel/$$KERNEL_MANUFACTURER/$$KERNEL_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone kernel source, continuing without it"
        else
          echo "‚úÖ Kernel source cloned to kernel/$$KERNEL_MANUFACTURER/$$KERNEL_NAME"
        fi
      fi
      
      if [ -n "$$VENDOR_TREE_URL" ]; then
        echo "üè¢ Cloning vendor blobs from: $$VENDOR_TREE_URL"
        # Use same manufacturer as device
        VENDOR_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        case "$$VENDOR_NAME" in
          garnet)
            VENDOR_MANUFACTURER="xiaomi"
            ;;
          *)
            VENDOR_MANUFACTURER="$$(echo "$$VENDOR_TREE_URL" | sed -n 's/.*vendor_\([^_]*\)_.*/\1/p')"
            if [ -z "$$VENDOR_MANUFACTURER" ]; then
              VENDOR_MANUFACTURER="unknown"
            fi
            ;;
        esac
        
        echo "üè¢ Vendor: $$VENDOR_MANUFACTURER/$$VENDOR_NAME"
        mkdir -p "vendor/$$VENDOR_MANUFACTURER"
        if ! git clone "$$VENDOR_TREE_URL" -b "$$VENDOR_TREE_BRANCH" "vendor/$$VENDOR_MANUFACTURER/$$VENDOR_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone vendor tree, continuing without it"
        else
          echo "‚úÖ Vendor blobs cloned to vendor/$$VENDOR_MANUFACTURER/$$VENDOR_NAME"
        fi
      fi
      
      # Upload artifacts
      cd ..
      buildkite-agent artifact upload "$$SYNC_LOG"
      buildkite-agent artifact upload "logs/sync-analytics.json"
    agents:
      queue: "default"
    timeout_in_minutes: 180
    retry:
      automatic:
        - exit_status: 1
          limit: 3
        - exit_status: 124
          limit: 3
    artifact_paths:
      - "logs/sync-*.log"
      - "logs/sync-analytics.json"
    concurrency_group: "source-sync"
    concurrency: 2

  - label: ":shield: Security & Vulnerability Scanning"
    key: "security-scan"
    depends_on: "source-sync"
    command: |
      set -euo pipefail
      
      echo "üîí Running comprehensive security scans..."
      
      # Create security logs directory
      mkdir -p logs/security
      
      # Import notification functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      send_telegram "üîí *Security Scanning*%0A%0Aüîç Running vulnerability scans on source code..."
      
      cd android-workspace
      
      # Install Trivy if enabled and not present
      if [ "$$ENABLE_TRIVY_SCAN" = "true" ]; then
        if ! command -v trivy &> /dev/null; then
          echo "üì• Installing Trivy security scanner..."
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
        fi
        
        echo "üîç Running Trivy filesystem scan..."
        trivy fs --format json --output ../logs/security/trivy-scan.json \
          --severity $$VULNERABILITY_SEVERITY_THRESHOLD \
          --exit-code 0 . || echo "‚ö†Ô∏è Trivy scan completed with findings"
        
        # Generate human-readable report
        trivy fs --format table --output ../logs/security/trivy-report.txt \
          --severity $$VULNERABILITY_SEVERITY_THRESHOLD . || true
      fi
      
      # Source code quality analysis
      echo "üìä Analyzing source code quality..."
      {
        echo "=== SOURCE CODE ANALYSIS ==="
        echo "Repository size: $$(du -sh . | cut -f1)"
        echo "Total files: $$(find . -type f | wc -l)"
        echo "C/C++ files: $$(find . -name "*.c" -o -name "*.cpp" -o -name "*.cc" | wc -l)"
        echo "Java files: $$(find . -name "*.java" | wc -l)"
        echo "Kotlin files: $$(find . -name "*.kt" | wc -l)"
        echo "XML files: $$(find . -name "*.xml" | wc -l)"
        echo "Makefiles: $$(find . -name "Makefile" -o -name "*.mk" | wc -l)"
        echo "Build files: $$(find . -name "Android.bp" -o -name "BUILD.bazel" | wc -l)"
        echo "Completed: $$(date -Iseconds)"
      } > ../logs/security/source-analysis.txt
      
      # Check for sensitive files that shouldn't be in source
      echo "üîç Checking for sensitive files..."
      {
        echo "=== SENSITIVE FILE SCAN ==="
        echo "Private keys:"
        find . -name "*.pem" -o -name "*.key" -o -name "*.p12" -o -name "*.jks" | head -10
        echo "Potential secrets:"
        find . -name "*.properties" -exec grep -l -i "password\|secret\|token\|key" {} \; 2>/dev/null | head -10
        echo "Completed: $$(date -Iseconds)"
      } > ../logs/security/sensitive-files.txt
      
      echo "‚úÖ Security scanning completed"
      
      # Upload security reports
      cd ..
      buildkite-agent artifact upload "logs/security/*.json"
      buildkite-agent artifact upload "logs/security/*.txt"
    agents:
      queue: "default"
    timeout_in_minutes: 30
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    artifact_paths:
      - "logs/security/*.json"
      - "logs/security/*.txt"
    continue_on_failure: true

  - wait: ~
    continue_on_failure: false

  - label: ":building_construction: Android ROM Build"
    key: "android-build"
    depends_on: "source-sync"
    command: |
      set -euo pipefail
      
      echo "üöÄ Android ROM Build System Initiated"
      
      # Import utility functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      # AI healing function
      ai_heal_error() {
        local error_message="$$1"
        local step_name="$$2"
        local attempt="$$3"
        
        if [ "$$ENABLE_AI_HEALING" != "true" ] || [ -z "$$GEMINI_API_KEY" ] || [ "$$attempt" -gt "$$AI_MAX_RETRIES" ]; then
          return 1
        fi
        
        echo "ü§ñ AI Healing: Analyzing build error with Gemini..."
        
        local prompt="You are an expert Android ROM build engineer. Analyze this build error and provide a specific fix:
        
        Step: $$step_name
        Error: $$error_message
        
        Provide a concise bash command or solution to fix this specific error. Focus on practical fixes for Android ROM building."
        
        local response=$$(curl -s -X POST "$$GEMINI_BASE_URL/v1beta/models/$$GEMINI_MODEL:generateContent" \
          -H "Content-Type: application/json" \
          -H "x-goog-api-key: $$GEMINI_API_KEY" \
          -d "{
            \"contents\": [{
              \"parts\": [{
                \"text\": \"$$prompt\"
              }]
            }]
          }" 2>/dev/null)
        
        if [ $$? -eq 0 ] && [ -n "$$response" ]; then
          local suggestion=$$(echo "$$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('candidates', [{}])[0].get('content', {}).get('parts', [{}])[0].get('text', 'No suggestion'))" 2>/dev/null)
          
          if [ -n "$$suggestion" ] && [ "$$suggestion" != "No suggestion" ]; then
            echo "ü§ñ AI Suggestion: $$suggestion"
            send_telegram "ü§ñ *AI Build Healing*%0Aüí° Suggestion: $$suggestion"
            return 0
          fi
        fi
        
        return 1
      }
      
      # Send build start notification
      send_telegram "üèóÔ∏è *Starting ROM Build*%0A%0Aüì± Device: $$TARGET_DEVICE%0AüéØ ROM: $$ROM_TYPE%0A‚öôÔ∏è Using all 12 CPU cores"
      
      cd android-workspace
      
      # Advanced build monitoring initialization
      BUILD_START=$$(date +%s)
      BUILD_ID="build-$$(date +%Y%m%d-%H%M%S)"
      BUILD_LOG="../logs/$$BUILD_ID.log"
      RESOURCE_LOG="../logs/resource-usage-$$(date +%Y%m%d-%H%M%S).log"
      PERFORMANCE_LOG="../logs/build-performance-$$(date +%Y%m%d-%H%M%S).log"
      
      # Get optimized build jobs from metadata if available
      OPTIMIZED_BUILD_JOBS=$$(buildkite-agent meta-data get "optimized-build-jobs" 2>/dev/null || echo "$$BUILD_JOBS")
      BUILD_JOBS="$$OPTIMIZED_BUILD_JOBS"
      
      {
        echo "=== ADVANCED ANDROID ROM BUILD ==="
        echo "Build ID: $$BUILD_ID"
        echo "Started: $$(date -Iseconds)"
        echo "Target Device: $$TARGET_DEVICE"
        echo "Build Variant: $$BUILD_VARIANT"
        echo "Build Type: $$BUILD_TYPE"
        echo "Build Jobs: $$BUILD_JOBS (optimized)"
        echo "ccache Size: $$CCACHE_SIZE"
        echo "Clean Build: $$CLEAN_BUILD"
        echo "ROM Type: $$ROM_TYPE"
        echo ""
      } > "$$BUILD_LOG"
      
      echo "üèóÔ∏è Enhanced Build Configuration:"
      echo "   ‚Ä¢ Build Jobs: $$BUILD_JOBS (optimized)"
      echo "   ‚Ä¢ ccache: $$CCACHE_SIZE with compression"
      echo "   ‚Ä¢ Target: $$TARGET_DEVICE"
      echo "   ‚Ä¢ ROM: $$ROM_TYPE"
      echo "   ‚Ä¢ Performance Monitoring: Enabled"
      
      # Enhanced resource monitoring with performance profiling
      monitor_resources() {
        echo "timestamp,cpu_usage,memory_usage,disk_usage,load_avg,ccache_hits,build_stage,temp_c" > "$$RESOURCE_LOG"
        echo "timestamp,stage,duration_seconds,memory_peak_mb,cpu_avg_percent,io_wait" > "$$PERFORMANCE_LOG"
        
        local stage_start=$$(date +%s)
        local current_stage="initialization"
        local last_cpu_usage=0
        local last_mem_usage=0
        
        while true; do
          # Enhanced resource collection with error handling
          CPU_USAGE=$$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 2>/dev/null || echo "0")
          MEM_USAGE=$$(free | awk '/^Mem:/ {printf "%.1f", ($3/$2)*100}' 2>/dev/null || echo "0")
          DISK_USAGE=$$(df -h . | awk 'NR==2 {print $5}' | cut -d'%' -f1 2>/dev/null || echo "0")
          LOAD_AVG=$$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',' 2>/dev/null || echo "0")
          
          # ccache statistics with error handling
          CCACHE_HITS="0"
          if command -v ccache >/dev/null 2>&1; then
            CCACHE_HITS=$$(ccache -s 2>/dev/null | grep 'cache hit rate' | awk '{print $4}' | tr -d '%' || echo "0")
          fi
          
          # CPU temperature monitoring (if available)
          CPU_TEMP="N/A"
          if [ -f /sys/class/thermal/thermal_zone0/temp ]; then
            CPU_TEMP=$$(($(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null || echo "0") / 1000))
          fi
          
          # Detect build stage based on running processes
          if pgrep -f "ninja.*build.ninja" >/dev/null; then
            current_stage="ninja_build"
          elif pgrep -f "javac" >/dev/null; then
            current_stage="java_compilation"  
          elif pgrep -f "dex2oat" >/dev/null; then
            current_stage="dex_optimization"
          elif pgrep -f "soong" >/dev/null; then
            current_stage="soong_build"
          elif pgrep -f "aapt" >/dev/null; then
            current_stage="resource_compilation"
          fi
          
          # Log detailed metrics
          echo "$$(date -Iseconds),$$CPU_USAGE,$$MEM_USAGE,$$DISK_USAGE,$$LOAD_AVG,$$CCACHE_HITS,$$current_stage,$$CPU_TEMP" >> "$$RESOURCE_LOG"
          
          # Performance alerts with actionable recommendations
          if [ "$$(echo "$$CPU_USAGE > 95" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
            echo "‚ö†Ô∏è CPU overloaded ($$CPU_USAGE%) - Stage: $$current_stage"
            if [ "$$current_stage" = "ninja_build" ] && [ "$$BUILD_JOBS" -gt 4 ]; then
              echo "üí° Consider reducing BUILD_JOBS from $$BUILD_JOBS to $$((BUILD_JOBS - 2))"
            fi
          fi
          
          if [ "$$(echo "$$MEM_USAGE > 85" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
            echo "‚ö†Ô∏è High memory usage ($$MEM_USAGE%) - Stage: $$current_stage"
            if [ "$$(echo "$$MEM_USAGE > 95" | bc -l 2>/dev/null || echo 0)" -eq 1 ]; then
              echo "üö® Critical memory usage - OOM risk!"
              send_telegram "üö® *Critical Memory Alert*%0AUsage: $${MEM_USAGE}%%0AStage: $$current_stage" || true
            fi
          fi
          
          # Temperature monitoring
          if [ "$$CPU_TEMP" != "N/A" ] && [ "$$CPU_TEMP" -gt 80 ]; then
            echo "üå°Ô∏è High CPU temperature: $${CPU_TEMP}¬∞C"
            if [ "$$CPU_TEMP" -gt 90 ]; then
              echo "üî• Critical temperature - may cause thermal throttling"
            fi
          fi
          
          # Store previous values for trend analysis
          last_cpu_usage="$$CPU_USAGE"
          last_mem_usage="$$MEM_USAGE"
          
          sleep 30
        done &
        MONITOR_PID=$$!
        echo "üìä Enhanced resource monitoring started (PID: $$MONITOR_PID)"
      }
      
      # Maximum performance build job calculation
      calculate_build_jobs() {
        local cores=$$(nproc)
        local ram_gb=$$(free -g | awk '/^Mem:/ {print $$2}')
        local jobs
        
        if [ -n "$$BUILD_JOBS" ]; then
          jobs="$$BUILD_JOBS"
          echo "üîß Using specified build jobs: $$jobs (FULL POWER MODE)"
        else
          # Use all available cores for maximum performance
          jobs=$$cores
          echo "üöÄ FULL POWER: Using all $$cores CPU cores ($$ram_gb GB RAM)"
        fi
        
        echo "$$jobs"
      }
      
      # Start resource monitoring
      monitor_resources
      
      # Calculate build jobs
      BUILD_JOBS_CALCULATED=$$(calculate_build_jobs)
      
      # Set up build environment
      echo "üîß Configuring advanced build environment..."
      
      # Export Android build environment
      export USE_CCACHE=1
      export CCACHE_DIR="$$HOME/.ccache"
      export ANDROID_JACK_VM_ARGS="-Xmx4g -Dfile.encoding=UTF-8 -XX:+TieredCompilation"
      export JACK_SERVER_VM_ARGUMENTS="-Xmx4g -Dfile.encoding=UTF-8 -XX:+TieredCompilation"
      
      # Configure Java environment
      export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
      export PATH=$$JAVA_HOME/bin:$$PATH
      
      # Advanced build optimization
      if [ "$$ram_gb" -ge 32 ]; then
        export ANDROID_COMPILE_WITH_JACK=true
        export DEFAULT_JACK_EXTRA_ARGS="--multi-dex=native"
      fi
      
      # Clean build if requested
      if [ "$$CLEAN_BUILD" = "true" ]; then
        echo "üßπ Performing clean build..."
        if [ -d "out" ]; then
          rm -rf out
        fi
        make clean 2>/dev/null || true
        ccache -C
      fi
      
      # Source build environment
      echo "üìã Sourcing build environment..."
      source build/envsetup.sh
      
      # Device configuration and validation
      echo "üîç Configuring target device: $$TARGET_DEVICE"
      
      if ! lunch "$$TARGET_DEVICE" 2>&1 | tee -a "$$BUILD_LOG"; then
        echo "‚ùå Failed to configure device: $$TARGET_DEVICE"
        exit 1
      fi
      
      # Enhanced pre-build verification
      echo "üîç Pre-build verification..."
      
      # Verify essential build components
      VERIFICATION_FAILED=false
      
      # Check for essential directories
      for dir in build system frameworks vendor; do
        if [ ! -d "$$dir" ]; then
          echo "‚ùå Missing essential directory: $$dir"
          VERIFICATION_FAILED=true
        fi
      done
      
      # Check available disk space (need at least 100GB for Android build)
      AVAILABLE_SPACE_GB=$$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
      if [ "$$AVAILABLE_SPACE_GB" -lt 100 ]; then
        echo "‚ö†Ô∏è Low disk space: $${AVAILABLE_SPACE_GB}GB available (recommended: 150GB+)"
        echo "   Build may fail due to insufficient space"
      else
        echo "‚úÖ Sufficient disk space: $${AVAILABLE_SPACE_GB}GB available"
      fi
      
      if [ "$$VERIFICATION_FAILED" = "true" ]; then
        echo "‚ùå Pre-build verification failed - continuing anyway"
        send_telegram "‚ö†Ô∏è *Pre-build Warning*%0ASome verification checks failed%0AContinuing build anyway..." || true
      else
        echo "‚úÖ Pre-build verification passed"
      fi
      
      # Enhanced build execution with comprehensive monitoring
      echo "üèóÔ∏è Starting enhanced ROM build with advanced monitoring..."
      
      {
        echo "=== ENHANCED BUILD EXECUTION ==="
        echo "Build Jobs: $$BUILD_JOBS_CALCULATED (optimized)"
        echo "Ccache Size: $$(ccache -s | head -1 || echo 'ccache not available')"
        echo "Java Version: $$(java -version 2>&1 | head -1 || echo 'Java not detected')"
        echo "Build Command: make -j$$BUILD_JOBS_CALCULATED bacon"
        echo "Performance Monitoring: Enabled"
        echo "AI Healing: $$ENABLE_AI_HEALING"
        echo "Available Disk Space: $${AVAILABLE_SPACE_GB}GB"
        echo "Started: $$(date -Iseconds)"
        echo ""
      } | tee -a "$$BUILD_LOG"
      
      # Execute build with comprehensive error handling
      if ! make -j"$$BUILD_JOBS_CALCULATED" bacon 2>&1 | tee -a "$$BUILD_LOG"; then
        BUILD_EXIT_CODE=$$?
        echo "‚ùå Build failed with exit code: $$BUILD_EXIT_CODE"
        
        # Kill monitoring process
        if [ -n "$${MONITOR_PID:-}" ]; then
          kill "$$MONITOR_PID" 2>/dev/null || true
        fi
        
        # Comprehensive build failure analysis
        echo "üîç Analyzing build failure..."
        
        # Check for common failure patterns
        if grep -q "FAILED.*ninja" "$$BUILD_LOG"; then
          echo "üí• Ninja build system failure detected"
          echo "üîß Recommendation: Check for missing dependencies or corrupted source"
        elif grep -q "out of memory\|Cannot allocate memory" "$$BUILD_LOG"; then
          echo "üí• Out of memory error detected"
          echo "üîß Recommendation: Reduce build jobs or increase system memory"
        elif grep -q "No space left on device" "$$BUILD_LOG"; then
          echo "üí• Disk space exhausted"
          echo "üîß Recommendation: Clean build directory or expand storage"
        elif grep -q "fatal.*killed" "$$BUILD_LOG"; then
          echo "üí• Build process was killed (likely OOM)"
          echo "üîß Recommendation: Reduce concurrent jobs and enable swap"
        fi
        
        # Generate failure report
        {
          echo "{"
          echo "  \"timestamp\": \"$$(date -Iseconds)\","
          echo "  \"build_id\": \"$$BUILD_ID\","
          echo "  \"exit_code\": $$BUILD_EXIT_CODE,"
          echo "  \"duration_seconds\": $$(($(date +%s) - BUILD_START)),"
          echo "  \"target_device\": \"$$TARGET_DEVICE\","
          echo "  \"build_jobs\": $$BUILD_JOBS_CALCULATED,"
          echo "  \"status\": \"failed\""
          echo "}"
        } > "../logs/build-failure-$$BUILD_ID.json"
        
        exit $$BUILD_EXIT_CODE
      fi
      
      # Kill monitoring process
      if [ -n "$${MONITOR_PID:-}" ]; then
        kill "$$MONITOR_PID" 2>/dev/null || true
      fi
      
      # Enhanced build success processing and verification
      BUILD_END=$$(date +%s)
      BUILD_DURATION=$$((BUILD_END - BUILD_START))
      BUILD_HOURS=$$((BUILD_DURATION / 3600))
      BUILD_MINUTES=$$(((BUILD_DURATION % 3600) / 60))
      BUILD_SECONDS=$$((BUILD_DURATION % 60))
      
      echo "‚úÖ Build completed successfully!"
      echo "‚è±Ô∏è Total build time: $${BUILD_HOURS}h $${BUILD_MINUTES}m $${BUILD_SECONDS}s"
      
      # Post-build verification and analysis
      echo "üîç Post-build verification and analysis..."
      
      DEVICE_OUT="out/target/product"
      BUILD_SUCCESS=true
      ARTIFACTS_FOUND=0
      
      if [ -d "$$DEVICE_OUT" ]; then
        DEVICE_DIR=$$(ls "$$DEVICE_OUT" | head -1)
        if [ -n "$$DEVICE_DIR" ]; then
          ARTIFACT_PATH="$$DEVICE_OUT/$$DEVICE_DIR"
          
          # Verify essential build outputs exist
          echo "üìã Verifying build outputs..."
          
          # Check for ROM zip file
          ROM_FILE=$$(find "$$ARTIFACT_PATH" -name "*.zip" -not -name "*-ota-*.zip" | head -1)
          if [ -n "$$ROM_FILE" ]; then
            ROM_SIZE=$$(stat -c%s "$$ROM_FILE" | numfmt --to=iec-i)
            ROM_SIZE_MB=$$(stat -c%s "$$ROM_FILE" | awk '{printf "%.0f", $1/1024/1024}')
            echo "‚úÖ ROM file: $$(basename "$$ROM_FILE") ($$ROM_SIZE)"
            ARTIFACTS_FOUND=$$((ARTIFACTS_FOUND + 1))
            
            # Verify ROM file integrity
            if [ "$$ROM_SIZE_MB" -lt 500 ]; then
              echo "‚ö†Ô∏è ROM file seems unusually small ($$ROM_SIZE) - possible build issue"
              BUILD_SUCCESS=false
            fi
          else
            echo "‚ùå ROM zip file not found!"
            BUILD_SUCCESS=false
          fi
          
          # Check for boot image
          BOOT_IMG=$$(find "$$ARTIFACT_PATH" -name "boot.img" | head -1)
          if [ -n "$$BOOT_IMG" ]; then
            echo "‚úÖ Boot image: $$(basename "$$BOOT_IMG") ($$(stat -c%s "$$BOOT_IMG" | numfmt --to=iec-i))"
            ARTIFACTS_FOUND=$$((ARTIFACTS_FOUND + 1))
          else
            echo "‚ö†Ô∏è Boot image not found (may be included in ROM)"
          fi
          
          # Generate enhanced checksums and verification
          echo "üîê Generating security checksums and verification..."
          find "$$ARTIFACT_PATH" -name "*.zip" -o -name "*.img" | while read -r file; do
            if [ -f "$$file" ]; then
              echo "Processing: $$(basename "$$file")"
              md5sum "$$file" > "$${file}.md5"
              sha256sum "$$file" > "$${file}.sha256"
              
              # Create verification script
              cat > "$${file}.verify" << 'EOF'
#!/bin/bash
# ROM Verification Script
echo "Verifying ROM integrity..."
if md5sum -c "$(basename "$1").md5" && sha256sum -c "$(basename "$1").sha256"; then
  echo "‚úÖ ROM integrity verified successfully"
else
  echo "‚ùå ROM integrity check failed!"
  exit 1
fi
EOF
              chmod +x "$${file}.verify"
            fi
          done
          
          # Enhanced build manifest with detailed analysis
          {
            echo "=== ENHANCED BUILD MANIFEST ==="
            echo "Build ID: $$BUILD_ID"
            echo "Pipeline Version: $$PIPELINE_VERSION"
            echo "Completed: $$(date -Iseconds)"
            echo "Build Duration: $${BUILD_HOURS}h $${BUILD_MINUTES}m $${BUILD_SECONDS}s"
            echo "Target Device: $$TARGET_DEVICE"
            echo "ROM Type: $$ROM_TYPE"
            echo "Build Jobs Used: $$BUILD_JOBS_CALCULATED"
            echo "Build Success: $$BUILD_SUCCESS"
            echo "Artifacts Found: $$ARTIFACTS_FOUND"
            echo ""
            echo "=== PERFORMANCE METRICS ==="
            echo "Average CPU Usage: $$(tail -n 100 "$$RESOURCE_LOG" 2>/dev/null | awk -F',' '{sum+=$2; count++} END {printf "%.1f%%", sum/count}' || echo "N/A")"
            echo "Peak Memory Usage: $$(tail -n 100 "$$RESOURCE_LOG" 2>/dev/null | awk -F',' 'BEGIN{max=0} {if($3>max) max=$3} END {printf "%.1f%%", max}' || echo "N/A")"
            echo "ccache Hit Rate: $$(ccache -s | grep 'cache hit rate' | awk '{print $4}' || echo "N/A")"
            echo ""
            echo "=== BUILD ARTIFACTS ==="
            find "$$ARTIFACT_PATH" -name "*.zip" -o -name "*.img" | while read -r file; do
              if [ -f "$$file" ]; then
                FILE_SIZE=$$(stat -c%s "$$file" | numfmt --to=iec-i)
                FILE_MD5=$$(cat "$${file}.md5" | awk '{print $1}')
                echo "File: $$(basename "$$file")"
                echo "  Size: $$FILE_SIZE"
                echo "  MD5: $$FILE_MD5"
                echo "  Path: $$file"
                echo ""
              fi
            done
            echo "=== BUILD ENVIRONMENT ==="
            echo "CPU Cores: $$(nproc)"
            echo "Total RAM: $$(free -h | awk '/^Mem:/ {print $2}')"
            echo "Available Disk: $${AVAILABLE_SPACE_GB}GB"
            echo "OS: $$(lsb_release -d | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '"')"
            echo "Buildkite Agent: $$BUILDKITE_AGENT_NAME"
          } > "../logs/build-manifest-$$BUILD_ID.txt"
          
          # Performance analytics
          {
            echo "{"
            echo "  \"build_id\": \"$$BUILD_ID\","
            echo "  \"pipeline_version\": \"$$PIPELINE_VERSION\","
            echo "  \"timestamp\": \"$$(date -Iseconds)\","
            echo "  \"duration_seconds\": $$BUILD_DURATION,"
            echo "  \"target_device\": \"$$TARGET_DEVICE\","
            echo "  \"rom_type\": \"$$ROM_TYPE\","
            echo "  \"build_jobs\": $$BUILD_JOBS_CALCULATED,"
            echo "  \"artifacts_count\": $$ARTIFACTS_FOUND,"
            echo "  \"build_success\": $$BUILD_SUCCESS,"
            echo "  \"cpu_cores\": $$(nproc),"
            echo "  \"total_ram_gb\": $$(free -g | awk '/^Mem:/ {print $2}'),"
            echo "  \"ccache_hit_rate\": \"$$(ccache -s | grep 'cache hit rate' | awk '{print $4}' || echo 'N/A')\""
            echo "}"
          } > "../logs/build-analytics-$$BUILD_ID.json"
        fi
      fi
      
      if [ "$$BUILD_SUCCESS" != "true" ]; then
        echo "‚ö†Ô∏è Post-build verification detected issues - check build manifest for details"
      else
        echo "‚úÖ Post-build verification passed - ROM ready for deployment!"
      fi
      
      # Generate comprehensive build analytics
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"build_id\": \"$$BUILD_ID\","
        echo "  \"duration_seconds\": $$BUILD_DURATION,"
        echo "  \"target_device\": \"$$TARGET_DEVICE\","
        echo "  \"build_variant\": \"$$BUILD_VARIANT\","
        echo "  \"build_jobs\": $$BUILD_JOBS_CALCULATED,"
        echo "  \"ccache_hit_rate\": \"$$(ccache -s | grep 'cache hit rate' | awk '{print $$4}' || echo 'N/A')\","
        echo "  \"total_size_mb\": $$(du -sm out 2>/dev/null | cut -f1 || echo 0),"
        echo "  \"status\": \"success\""
        echo "}"
      } > "../logs/build-analytics-$$BUILD_ID.json"
      
      echo "‚úÖ Advanced Android ROM build completed successfully!"
      
      # Upload artifacts
      cd ..
      buildkite-agent artifact upload "$$BUILD_LOG"
      buildkite-agent artifact upload "logs/build-analytics-$$BUILD_ID.json"
      buildkite-agent artifact upload "logs/resource-usage-$$BUILD_ID.log"
      buildkite-agent artifact upload "logs/build-manifest-$$BUILD_ID.txt"
      
      # Upload ROM artifacts if they exist
      if [ -d "android-workspace/out/target/product" ]; then
        find android-workspace/out/target/product -name "*.zip" -o -name "*.img" -o -name "*.md5" -o -name "*.sha256" | while read -r file; do
          if [ -f "$$file" ]; then
            buildkite-agent artifact upload "$$file"
          fi
        done
      fi
    agents:
      queue: "default"
    timeout_in_minutes: 300
    retry:
      automatic:
        - exit_status: 130
          limit: 2
        - exit_status: 137
          limit: 2
    artifact_paths:
      - "logs/build-*.log"
      - "logs/build-analytics-*.json"
      - "logs/resource-usage-*.log"
      - "logs/build-manifest-*.txt"
      - "android-workspace/out/target/product/*/*.zip"
      - "android-workspace/out/target/product/*/*.img"
      - "android-workspace/out/target/product/*/*.md5"
      - "android-workspace/out/target/product/*/*.sha256"
    concurrency_group: "android-build"
    concurrency: 1

  - label: ":package: Build Artifact Management & Optimization"
    key: "artifact-management"
    depends_on: "android-build"
    command: |
      set -euo pipefail
      
      echo "üì¶ Advanced build artifact management and optimization..."
      
      # Import notification functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      send_telegram "üì¶ *Artifact Processing*%0A%0Aüîß Optimizing and packaging build artifacts..."
      
      # Create artifacts directory structure
      mkdir -p artifacts/{roms,images,logs,checksums,metadata}
      
      if [ -d "android-workspace/out/target/product" ]; then
        cd android-workspace/out/target/product
        DEVICE_DIR=$$(ls | head -1)
        
        if [ -n "$$DEVICE_DIR" ] && [ -d "$$DEVICE_DIR" ]; then
          echo "üì± Processing artifacts for device: $$DEVICE_DIR"
          cd "$$DEVICE_DIR"
          
          # Find and process ROM files
          echo "üîç Discovering build artifacts..."
          ROM_FILES=$$(find . -name "*.zip" -not -name "*-ota-*.zip" -not -name "*-img-*.zip")
          IMAGE_FILES=$$(find . -name "*.img")
          OTA_FILES=$$(find . -name "*-ota-*.zip")
          
          # Process ROM files
          for rom_file in $$ROM_FILES; do
            if [ -f "$$rom_file" ]; then
              ROM_NAME=$$(basename "$$rom_file")
              ROM_SIZE=$$(stat -c%s "$$rom_file" | numfmt --to=iec-i)
              ROM_SIZE_MB=$$(stat -c%s "$$rom_file" | awk '{printf "%.0f", $$1/1024/1024}')
              
              echo "üì± Processing ROM: $$ROM_NAME ($$ROM_SIZE)"
              
              # Copy to artifacts directory
              cp "$$rom_file" "../../../../../artifacts/roms/"
              
              # Generate enhanced checksums
              echo "üîê Generating security checksums for $$ROM_NAME..."
              cd "../../../../../artifacts/roms/"
              md5sum "$$ROM_NAME" > "$${ROM_NAME}.md5"
              sha1sum "$$ROM_NAME" > "$${ROM_NAME}.sha1"
              sha256sum "$$ROM_NAME" > "$${ROM_NAME}.sha256"
              sha512sum "$$ROM_NAME" > "$${ROM_NAME}.sha512"
              
              # Create verification script
              cat > "$${ROM_NAME}.verify.sh" << 'VERIFY_EOF'
#!/bin/bash
# ROM Integrity Verification Script
ROM_FILE="$1"
if [ -z "$$ROM_FILE" ]; then
    ROM_FILE="$(basename "$$0" .verify.sh)"
fi

echo "üîê Verifying ROM integrity: $$ROM_FILE"
echo "=================================================="

VERIFICATION_PASSED=0

if [ -f "$${ROM_FILE}.md5" ]; then
    echo "üîç MD5 verification..."
    if md5sum -c "$${ROM_FILE}.md5" --quiet; then
        echo "‚úÖ MD5 checksum verified"
        VERIFICATION_PASSED=$$((VERIFICATION_PASSED + 1))
    else
        echo "‚ùå MD5 checksum failed"
    fi
fi

if [ -f "$${ROM_FILE}.sha256" ]; then
    echo "üîç SHA256 verification..."
    if sha256sum -c "$${ROM_FILE}.sha256" --quiet; then
        echo "‚úÖ SHA256 checksum verified"
        VERIFICATION_PASSED=$$((VERIFICATION_PASSED + 1))
    else
        echo "‚ùå SHA256 checksum failed"
    fi
fi

if [ $$VERIFICATION_PASSED -eq 2 ]; then
    echo ""
    echo "üéâ ROM integrity verification successful!"
    echo "The ROM file is authentic and has not been tampered with."
    exit 0
else
    echo ""
    echo "üí• ROM integrity verification failed!"
    echo "Do not flash this ROM as it may be corrupted or tampered with."
    exit 1
fi
VERIFY_EOF
              chmod +x "$${ROM_NAME}.verify.sh"
              
              # Generate ROM info file
              {
                echo "ROM_NAME=$$ROM_NAME"
                echo "ROM_SIZE_BYTES=$$(stat -c%s "$$ROM_NAME")"
                echo "ROM_SIZE_HUMAN=$$ROM_SIZE"
                echo "ROM_SIZE_MB=$$ROM_SIZE_MB"
                echo "BUILD_DATE=$$(date -Iseconds)"
                echo "BUILD_NUMBER=$$BUILDKITE_BUILD_NUMBER"
                echo "DEVICE=$$DEVICE_DIR"
                echo "ROM_TYPE=$$ROM_TYPE"
                echo "TARGET_DEVICE=$$TARGET_DEVICE"
                echo "BUILD_VARIANT=$$BUILD_VARIANT"
                echo "PIPELINE_VERSION=$$PIPELINE_VERSION"
              } > "$${ROM_NAME}.info"
              
              cd "../../out/target/product/$$DEVICE_DIR"
            fi
          done
          
          # Process image files
          for img_file in $$IMAGE_FILES; do
            if [ -f "$$img_file" ]; then
              IMG_NAME=$$(basename "$$img_file")
              IMG_SIZE=$$(stat -c%s "$$img_file" | numfmt --to=iec-i)
              
              echo "üíæ Processing image: $$IMG_NAME ($$IMG_SIZE)"
              
              # Copy to artifacts directory
              cp "$$img_file" "../../../../../artifacts/images/"
              
              # Generate checksums for images
              cd "../../../../../artifacts/images/"
              md5sum "$$IMG_NAME" > "$${IMG_NAME}.md5"
              sha256sum "$$IMG_NAME" > "$${IMG_NAME}.sha256"
              
              cd "../../out/target/product/$$DEVICE_DIR"
            fi
          done
          
          # Process OTA files if any
          for ota_file in $$OTA_FILES; do
            if [ -f "$$ota_file" ]; then
              OTA_NAME=$$(basename "$$ota_file")
              OTA_SIZE=$$(stat -c%s "$$ota_file" | numfmt --to=iec-i)
              
              echo "üîÑ Processing OTA: $$OTA_NAME ($$OTA_SIZE)"
              cp "$$ota_file" "../../../../../artifacts/roms/"
              
              # Generate checksums for OTA
              cd "../../../../../artifacts/roms/"
              md5sum "$$OTA_NAME" > "$${OTA_NAME}.md5"
              sha256sum "$$OTA_NAME" > "$${OTA_NAME}.sha256"
              
              cd "../../out/target/product/$$DEVICE_DIR"
            fi
          done
        fi
      fi
      
      # Return to project root
      cd ../../../../../..
      
      # Copy all checksums to dedicated directory
      find artifacts -name "*.md5" -o -name "*.sha*" | while read -r checksum_file; do
        cp "$$checksum_file" "artifacts/checksums/"
      done
      
      # Generate comprehensive build manifest
      {
        echo "{"
        echo "  \"build_info\": {"
        echo "    \"pipeline_version\": \"$$PIPELINE_VERSION\","
        echo "    \"build_number\": \"$$BUILDKITE_BUILD_NUMBER\","
        echo "    \"build_date\": \"$$(date -Iseconds)\","
        echo "    \"target_device\": \"$$TARGET_DEVICE\","
        echo "    \"rom_type\": \"$$ROM_TYPE\","
        echo "    \"build_variant\": \"$$BUILD_VARIANT\","
        echo "    \"agent_name\": \"$$BUILDKITE_AGENT_NAME\""
        echo "  },"
        echo "  \"artifacts\": {"
        echo "    \"roms\": ["
        for rom in artifacts/roms/*.zip; do
          if [ -f "$$rom" ]; then
            ROM_BASE=$$(basename "$$rom")
            echo "      {"
            echo "        \"filename\": \"$$ROM_BASE\","
            echo "        \"size_bytes\": $$(stat -c%s "$$rom"),"
            echo "        \"size_human\": \"$$(stat -c%s "$$rom" | numfmt --to=iec-i)\","
            echo "        \"md5\": \"$$(cat "artifacts/roms/$${ROM_BASE}.md5" | awk '{print $$1}' 2>/dev/null || echo 'N/A')\","
            echo "        \"sha256\": \"$$(cat "artifacts/roms/$${ROM_BASE}.sha256" | awk '{print $$1}' 2>/dev/null || echo 'N/A')\""
            echo "      },"
          fi
        done | sed '$s/,$//'
        echo "    ],"
        echo "    \"images\": ["
        for img in artifacts/images/*.img; do
          if [ -f "$$img" ]; then
            IMG_BASE=$$(basename "$$img")
            echo "      {"
            echo "        \"filename\": \"$$IMG_BASE\","
            echo "        \"size_bytes\": $$(stat -c%s "$$img"),"
            echo "        \"size_human\": \"$$(stat -c%s "$$img" | numfmt --to=iec-i)\","
            echo "        \"md5\": \"$$(cat "artifacts/images/$${IMG_BASE}.md5" | awk '{print $$1}' 2>/dev/null || echo 'N/A')\""
            echo "      },"
          fi
        done | sed '$s/,$//'
        echo "    ]"
        echo "  }"
        echo "}"
      } > artifacts/metadata/build-manifest.json
      
      # Create installation instructions
      cat > artifacts/INSTALLATION_GUIDE.md << 'INSTALL_EOF'
# ROM Installation Guide

## Prerequisites
- Unlocked bootloader
- Custom recovery (TWRP recommended)
- ADB and Fastboot tools installed
- At least 50% battery charge

## Installation Steps

### Method 1: Recovery Installation (Recommended)
1. Boot into recovery mode
2. Create a full backup (Nandroid backup)
3. Wipe: System, Data, Cache, Dalvik/ART Cache
4. Flash the ROM zip file
5. Flash GApps (if desired)
6. Reboot system

### Method 2: Fastboot Installation (Images)
1. Boot into fastboot mode
2. Flash individual images:
   ```bash
   fastboot flash boot boot.img
   fastboot flash system system.img
   fastboot flash vendor vendor.img
   ```
3. Wipe userdata: `fastboot -w`
4. Reboot: `fastboot reboot`

## Verification
Run the provided verification script before flashing:
```bash
chmod +x *.verify.sh
./ROM_FILE_NAME.verify.sh
```

## Support
- Device: Xiaomi Redmi Note 13 Pro 5G (garnet)
- Build Type: userdebug
- Build Date: $(date -Iseconds)

## Disclaimer
Flash at your own risk. Ensure you have a working backup before proceeding.
INSTALL_EOF
      
      # Generate download links file
      cat > artifacts/DOWNLOAD_INFO.txt << 'DOWNLOAD_EOF'
ROM Build Artifacts - Download Information
==========================================

Build Information:
- Device: $(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)
- ROM Type: $$ROM_TYPE
- Build Number: $$BUILDKITE_BUILD_NUMBER
- Build Date: $(date '+%Y-%m-%d %H:%M:%S')

Files Available:
DOWNLOAD_EOF
      
      # List all artifacts with sizes
      find artifacts -type f \( -name "*.zip" -o -name "*.img" \) | while read -r file; do
        FILENAME=$$(basename "$$file")
        FILESIZE=$$(stat -c%s "$$file" | numfmt --to=iec-i)
        echo "- $$FILENAME ($$FILESIZE)" >> artifacts/DOWNLOAD_INFO.txt
      done
      
      echo "" >> artifacts/DOWNLOAD_INFO.txt
      echo "Verification files included for all artifacts." >> artifacts/DOWNLOAD_INFO.txt
      echo "Always verify checksums before flashing!" >> artifacts/DOWNLOAD_INFO.txt
      
      echo "‚úÖ Artifact management completed"
      
      # Upload all artifacts
      buildkite-agent artifact upload "artifacts/**/*"
    agents:
      queue: "default"
    timeout_in_minutes: 30
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    artifact_paths:
      - "artifacts/**/*"

  - wait: ~
    continue_on_failure: false

  - label: ":bell: Build Notifications & Analytics"
    key: "notifications"
    depends_on: ["android-build", "artifact-management"]
    command: |
      set -euo pipefail
      
      echo "üìä Advanced build analytics and multi-platform notifications..."
      
      # Enhanced multi-platform notification functions
      send_telegram() {
        local message="$$1"
        local parse_mode="$${2:-Markdown}"
        
        if [ "$$ENABLE_TELEGRAM" = "true" ] && [ -n "$$TELEGRAM_BOT_TOKEN" ] && [ -n "$$TELEGRAM_CHAT_ID" ]; then
          curl -s -X POST "https://api.telegram.org/bot$$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d "chat_id=$$TELEGRAM_CHAT_ID" \
            -d "text=$$message" \
            -d "parse_mode=$$parse_mode" \
            -d "disable_web_page_preview=true" || true
        fi
      }
      
      send_slack() {
        local message="$$1"
        local color="$${2:-good}"
        
        if [ -n "$$SLACK_WEBHOOK_URL" ]; then
          curl -s -X POST "$$SLACK_WEBHOOK_URL" \
            -H "Content-type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"$$color\",
                \"text\": \"$$message\",
                \"footer\": \"Buildkite ROM Builder v$$PIPELINE_VERSION\",
                \"ts\": $$(date +%s)
              }]
            }" || true
        fi
      }
      
      send_discord() {
        local message="$$1"
        local color="$${2:-3066993}"
        
        if [ -n "$$DISCORD_WEBHOOK_URL" ]; then
          curl -s -X POST "$$DISCORD_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"embeds\": [{
                \"title\": \"ü§ñ ROM Build Update\",
                \"description\": \"$$message\",
                \"color\": $$color,
                \"footer\": {
                  \"text\": \"Buildkite ROM Builder v$$PIPELINE_VERSION\"
                },
                \"timestamp\": \"$$(date -Iseconds)\"
              }]
            }" || true
        fi
      }
      
      send_all_notifications() {
        local message="$$1"
        local telegram_message="$${2:-$$message}"
        local color="$${3:-good}"
        
        send_telegram "$$telegram_message"
        send_slack "$$message" "$$color"
        send_discord "$$message" "$$([ "$$color" = "danger" ] && echo "15158332" || echo "3066993")"
      }
      
      # Generate comprehensive build report
      BUILD_REPORT="logs/final-build-report-$$(date +%Y%m%d-%H%M%S).json"
      
      {
        echo "{"
        echo "  \"pipeline_version\": \"$$PIPELINE_VERSION\","
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"build_result\": \"$$BUILDKITE_BUILD_STATE\","
        echo "  \"target_device\": \"$$TARGET_DEVICE\","
        echo "  \"build_variant\": \"$$BUILD_VARIANT\","
        echo "  \"build_type\": \"$$BUILD_TYPE\","
        echo "  \"build_number\": \"$$BUILDKITE_BUILD_NUMBER\","
        echo "  \"commit_hash\": \"$$BUILDKITE_COMMIT\","
        echo "  \"branch\": \"$$BUILDKITE_BRANCH\","
        echo "  \"pipeline_slug\": \"$$BUILDKITE_PIPELINE_SLUG\","
        echo "  \"build_url\": \"$$BUILDKITE_BUILD_URL\","
        echo "  \"agent_name\": \"$$BUILDKITE_AGENT_NAME\""
        echo "}"
      } > "$$BUILD_REPORT"
      
      fi
      
      # Generate build summary statistics
      TOTAL_ARTIFACTS=$$(find artifacts -name "*.zip" -o -name "*.img" 2>/dev/null | wc -l || echo "0")
      TOTAL_SIZE=$$(find artifacts -name "*.zip" -o -name "*.img" 2>/dev/null -exec stat -c%s {} \; | awk '{sum+=$1} END {printf "%.1f", sum/1024/1024/1024}' || echo "0")
      BUILD_DURATION_READABLE="N/A"
      
      # Try to calculate build duration from logs
      if [ -f "logs/build-*.log" ]; then
        BUILD_START_TIME=$$(grep "Started:" logs/build-*.log | head -1 | awk '{print $2}' | cut -d'T' -f2 | cut -d'+' -f1 || echo "")
        if [ -n "$$BUILD_START_TIME" ]; then
          BUILD_DURATION_READABLE="~$$(date -d "$$BUILD_START_TIME" +%H:%M:%S || echo "N/A")"
        fi
      fi
      
      # Send enhanced final notifications
      if [ "$$BUILDKITE_BUILD_STATE" = "passed" ]; then
        TELEGRAM_MSG="üéâ *ROM BUILD SUCCESSFUL!* üéâ%0A%0Aüì± *Device:* $$TARGET_DEVICE%0AüéØ *ROM:* $$ROM_TYPE%0AüèóÔ∏è *Build #$$BUILDKITE_BUILD_NUMBER*%0A‚è∞ *Completed:* $$(date '+%Y-%m-%d %H:%M:%S')%0A‚è±Ô∏è *Duration:* $$BUILD_DURATION_READABLE%0A%0Aüìä *Build Results:*%0A‚úÖ Status: Successful%0Aüì¶ Artifacts: $$TOTAL_ARTIFACTS files%0Aüíæ Total Size: $${TOTAL_SIZE}GB%0Aüîê Security: MD5/SHA256 verified%0Aüõ°Ô∏è Scanned: Vulnerability checked%0A%0Aüì• *Downloads Available:*%0A‚Ä¢ ROM ZIP files%0A‚Ä¢ Individual IMG files%0A‚Ä¢ Verification scripts%0A‚Ä¢ Installation guide%0A%0Aüîó [Download Artifacts]($$BUILDKITE_BUILD_URL)"
        
        SLACK_MSG="üéâ ROM Build Successful! Device: $$TARGET_DEVICE | ROM: $$ROM_TYPE | Build #$$BUILDKITE_BUILD_NUMBER | Artifacts: $$TOTAL_ARTIFACTS files ($${TOTAL_SIZE}GB) | Security verified ‚úÖ"
        
        send_all_notifications "$$SLACK_MSG" "$$TELEGRAM_MSG" "good"
      else
        TELEGRAM_MSG="‚ùå *ROM BUILD FAILED* ‚ùå%0A%0Aüì± *Device:* $$TARGET_DEVICE%0AüéØ *ROM:* $$ROM_TYPE%0AüèóÔ∏è *Build #$$BUILDKITE_BUILD_NUMBER*%0A‚è∞ *Failed:* $$(date '+%Y-%m-%d %H:%M:%S')%0A‚è±Ô∏è *Duration:* $$BUILD_DURATION_READABLE%0A%0Aüí• *Failure Details:*%0A‚ùå Build process failed%0Aüìä Check build logs for details%0Aü§ñ AI healing may have attempted fixes%0Aüîß Manual intervention required%0A%0Aüîç *Troubleshooting:*%0A‚Ä¢ Review build logs%0A‚Ä¢ Check system resources%0A‚Ä¢ Verify network connectivity%0A‚Ä¢ Validate source integrity%0A%0Aüîó [View Logs]($$BUILDKITE_BUILD_URL)"
        
        SLACK_MSG="‚ùå ROM Build Failed! Device: $$TARGET_DEVICE | ROM: $$ROM_TYPE | Build #$$BUILDKITE_BUILD_NUMBER | Check logs for details"
        
        send_all_notifications "$$SLACK_MSG" "$$TELEGRAM_MSG" "danger"
      fi
      
      # Print build summary
      echo ""
      echo "üéØ ===== BUILD SUMMARY ====="
      echo "üì± Device: $$TARGET_DEVICE"
      echo "üéØ ROM: $$ROM_TYPE"
      echo "üèóÔ∏è Build: #$$BUILDKITE_BUILD_NUMBER"
      echo "üåü Status: $$BUILDKITE_BUILD_STATE"
      echo "üöÄ Pipeline: $$PIPELINE_VERSION"
      echo "üîó URL: $$BUILDKITE_BUILD_URL"
      echo "‚è∞ Completed: $$(date)"
      echo "======================"
      echo ""
      
      if [ "$$BUILDKITE_BUILD_STATE" = "passed" ]; then
        echo "üéâ Congratulations! Your Android ROM has been built successfully!"
        echo "üì¶ Check the artifacts section for your ROM files and installation instructions."
        echo "üîê All files include MD5 and SHA256 checksums for verification."
        echo "üöÄ Full CPU power utilized (12 cores) for maximum performance!"
      else
        echo "üí• Build failed. Check the logs for detailed error information."
        echo "ü§ñ AI healing may have attempted automatic fixes during the build process."
        echo "üîç Common solutions:"
        echo "   ‚Ä¢ Check build logs for specific errors"
        echo "   ‚Ä¢ Verify network connectivity for source sync issues"
        echo "   ‚Ä¢ Ensure sufficient disk space"
        echo "   ‚Ä¢ Verify target device configuration"
      fi
      
      # Upload final report
      buildkite-agent artifact upload "$$BUILD_REPORT"
      
      echo "‚úÖ Advanced ROM build process completed!"
    agents:
      queue: "default"
    timeout_in_minutes: 5
    artifact_paths:
      - "logs/final-build-report-*.json" 