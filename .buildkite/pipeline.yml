env:
  TERM: "xterm-256color"
  DEBIAN_FRONTEND: "noninteractive"
  LC_ALL: "C"

steps:
  - label: ":mag: Advanced System Diagnostics"
    key: "diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîç Running comprehensive system diagnostics..."
      
      # Create logs directory
      mkdir -p logs
      
      # System information
      {
        echo "=== SYSTEM INFORMATION ==="
        uname -a
        lsb_release -a 2>/dev/null || cat /etc/os-release
        
        echo -e "\n=== HARDWARE SPECS ==="
        echo "CPU Cores: $(nproc)"
        echo "CPU Info: $(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
        echo "Total RAM: $(free -h | awk '/^Mem:/ {print $2}')"
        echo "Available RAM: $(free -h | awk '/^Mem:/ {print $7}')"
        
        echo -e "\n=== DISK SPACE ==="
        df -h / /tmp 2>/dev/null || true
        
        echo -e "\n=== NETWORK ==="
        curl -s --max-time 10 https://httpbin.org/ip || echo "Network test failed"
        
        echo -e "\n=== JAVA VERSION ==="
        java -version 2>&1 || echo "Java not found"
        
        echo -e "\n=== PYTHON VERSION ==="
        python3 --version 2>&1 || echo "Python3 not found"
        
        echo -e "\n=== GIT VERSION ==="
        git --version 2>&1 || echo "Git not found"
        
      } | tee logs/system-diagnostics.log
      
      # Validate minimum requirements
      echo "üß™ Validating minimum requirements..."
      
      CORES=$(nproc)
      RAM_GB=$(free -g | awk '/^Mem:/ {print $2}')
      DISK_GB=$(df -BG / | awk 'NR==2 {print int($4)}')
      
      echo "üìä Resource Summary:"
      echo "  CPU Cores: $CORES (minimum: 4)"
      echo "  RAM: ${RAM_GB}GB (minimum: 16GB)"
      echo "  Disk Space: ${DISK_GB}GB (minimum: 200GB)"
      
      # Check requirements
      ERRORS=0
      
      if [ "$CORES" -lt 4 ]; then
        echo "‚ùå Insufficient CPU cores: $CORES < 4"
        ERRORS=$((ERRORS + 1))
      fi
      
      if [ "$RAM_GB" -lt 16 ]; then
        echo "‚ö†Ô∏è Warning: Low RAM: ${RAM_GB}GB < 16GB (may cause build failures)"
      fi
      
      if [ "$DISK_GB" -lt 200 ]; then
        echo "‚ùå Insufficient disk space: ${DISK_GB}GB < 200GB"
        ERRORS=$((ERRORS + 1))
      fi
      
      if [ "$ERRORS" -gt 0 ]; then
        echo "üí• $ERRORS critical errors found! Build may fail."
        echo "Please upgrade your agent hardware before proceeding."
        exit 1
      fi
      
      echo "‚úÖ All system requirements satisfied!"
      
      # Upload diagnostics
      buildkite-agent artifact upload "logs/system-diagnostics.log"
    agents:
      queue: "default"
    timeout_in_minutes: 5
    retry:
      automatic:
        - exit_status: "*"
          limit: 2

  - label: ":package: Advanced Dependency Management"
    key: "install-deps"
    depends_on: "diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîß Advanced Android build dependency installation..."
      
      # Function for retry logic
      retry_command() {
        local max_attempts=3
        local delay=5
        local command="$1"
        local attempt=1
        
        until [ $attempt -gt $max_attempts ]; do
          echo "Attempt $attempt/$max_attempts: $command"
          if eval "$command"; then
            return 0
          else
            echo "Command failed, retrying in ${delay}s..."
            sleep $delay
            delay=$((delay * 2))
            attempt=$((attempt + 1))
          fi
        done
        
        echo "‚ùå Command failed after $max_attempts attempts: $command"
        return 1
      }
      
      # Create installation log
      mkdir -p logs
      INSTALL_LOG="logs/dependency-install.log"
      
      {
        echo "=== DEPENDENCY INSTALLATION LOG ==="
        echo "Started: $(date)"
        echo "Host: $(hostname)"
        echo "User: $(whoami)"
        echo "Working Directory: $(pwd)"
        echo ""
      } > "$INSTALL_LOG"
      
      # Check if we're on a supported OS
      if ! command -v apt-get &> /dev/null; then
        echo "‚ùå This pipeline requires Ubuntu/Debian with apt-get"
        exit 1
      fi
      
      # Update package lists with retry
      echo "üì¶ Updating package lists..."
      retry_command "sudo apt-get update" 2>&1 | tee -a "$INSTALL_LOG"
      
      # Install essential packages
      echo "üî® Installing Android build dependencies..."
      
      PACKAGES=(
        # Core tools
        "git" "curl" "wget" "python3" "python3-pip" "python-is-python3"
        
        # Java development
        "openjdk-8-jdk" "openjdk-11-jdk"
        
        # Build tools
        "build-essential" "libc6-dev" "libssl-dev"
        
        # Android specific
        "libncurses5" "libncurses5-dev" "lib32ncurses5-dev"
        "libreadline-dev" "lib32readline-dev" "libtinfo5"
        "libxml2-utils" "xsltproc" "zip" "zlib1g-dev" "lib32z1-dev"
        
        # Multilib support
        "g++-multilib" "gcc-multilib"
        
        # Build optimization
        "ccache" "schedtool"
        
        # Additional tools
        "bison" "flex" "bc" "rsync" "squashfs-tools"
        "python3-mako" "libffi-dev"
        
        # System monitoring
        "htop" "iotop" "tree"
      )
      
      # Install packages in batches to avoid timeouts
      BATCH_SIZE=10
      for ((i=0; i<${#PACKAGES[@]}; i+=BATCH_SIZE)); do
        BATCH=("${PACKAGES[@]:i:BATCH_SIZE}")
        echo "Installing batch $((i/BATCH_SIZE + 1)): ${BATCH[*]}"
        
        retry_command "sudo apt-get install -y ${BATCH[*]}" 2>&1 | tee -a "$INSTALL_LOG"
      done
      
      # Configure Java environment
      echo "‚òï Configuring Java environment..."
      {
        echo "export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64"
        echo "export PATH=\$JAVA_HOME/bin:\$PATH"
      } >> ~/.bashrc
      
      export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
      export PATH=$JAVA_HOME/bin:$PATH
      
      # Install repo tool with verification
      echo "üîÑ Installing repo tool..."
      REPO_URL="https://storage.googleapis.com/git-repo-downloads/repo"
      
      retry_command "curl -o /tmp/repo '$REPO_URL'" 2>&1 | tee -a "$INSTALL_LOG"
      
      # Verify repo download
      if [ ! -f /tmp/repo ] || [ ! -s /tmp/repo ]; then
        echo "‚ùå Failed to download repo tool"
        exit 1
      fi
      
      sudo mv /tmp/repo /usr/local/bin/repo
      sudo chmod a+x /usr/local/bin/repo
      
      # Verify repo installation
      if ! repo --version &>/dev/null; then
        echo "‚ùå Repo tool installation failed"
        exit 1
      fi
      
      echo "‚úÖ Repo tool installed: $(repo --version)"
      
      # Set up ccache
      echo "üöÄ Configuring ccache..."
      export USE_CCACHE=1
      export CCACHE_DIR="${HOME}/.ccache"
      mkdir -p "$CCACHE_DIR"
      ccache -M 100G
      ccache -s
      
      # Configure git for repo
      echo "üîß Configuring git..."
      git config --global user.email "${GIT_EMAIL:-buildbot@buildkite.local}"
      git config --global user.name "${GIT_NAME:-Buildkite Android Builder}"
      git config --global color.ui auto
      
      # Final verification
      echo "üß™ Verifying installation..."
      {
        echo "=== INSTALLATION VERIFICATION ==="
        echo "Java: $(java -version 2>&1 | head -1)"
        echo "Python: $(python3 --version)"
        echo "Git: $(git --version)"
        echo "Repo: $(repo --version)"
        echo "Make: $(make --version | head -1)"
        echo "GCC: $(gcc --version | head -1)"
        echo "Ccache: $(ccache --version | head -1)"
        echo "Ccache config: $(ccache -s)"
        echo "Completed: $(date)"
      } | tee -a "$INSTALL_LOG"
      
      echo "‚úÖ All dependencies installed and verified!"
      
      # Upload installation log
      buildkite-agent artifact upload "$INSTALL_LOG"
    agents:
      queue: "default"
    timeout_in_minutes: 30
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    env:
      GIT_EMAIL: "buildbot@buildkite.local"
      GIT_NAME: "Buildkite Android Builder"

  - label: ":octocat: Smart Source Repository Initialization"
    key: "init-source"
    depends_on: "install-deps"
    command: |
      set -euo pipefail
      
      echo "üß† Smart Android source repository initialization..."
      
      # Configuration with validation
      MANIFEST_URL="${MANIFEST_URL:-https://github.com/LineageOS/android.git}"
      MANIFEST_BRANCH="${MANIFEST_BRANCH:-lineage-21.0}"
      MANIFEST_NAME="${MANIFEST_NAME:-default.xml}"
      
      # Create detailed log
      mkdir -p logs
      INIT_LOG="logs/source-init.log"
      
      {
        echo "=== SOURCE INITIALIZATION LOG ==="
        echo "Started: $(date)"
        echo "Manifest URL: $MANIFEST_URL"
        echo "Branch: $MANIFEST_BRANCH"
        echo "Manifest: $MANIFEST_NAME"
        echo ""
      } > "$INIT_LOG"
      
      # Validate manifest URL accessibility
      echo "üîç Validating manifest accessibility..." | tee -a "$INIT_LOG"
      
      if ! curl -s --head --fail "$MANIFEST_URL" >/dev/null 2>&1; then
        echo "‚ö†Ô∏è Direct URL check failed, trying git ls-remote..." | tee -a "$INIT_LOG"
        if ! git ls-remote "$MANIFEST_URL" >/dev/null 2>&1; then
          echo "‚ùå Manifest URL is not accessible: $MANIFEST_URL" | tee -a "$INIT_LOG"
          echo "Available alternatives:" | tee -a "$INIT_LOG"
          echo "  - LineageOS: https://github.com/LineageOS/android.git" | tee -a "$INIT_LOG"
          echo "  - AOSP: https://android.googlesource.com/platform/manifest" | tee -a "$INIT_LOG"
          exit 1
        fi
      fi
      
      echo "‚úÖ Manifest URL validated" | tee -a "$INIT_LOG"
      
      # Create source directory with proper permissions
      SOURCE_DIR="android-source"
      echo "üìÅ Setting up source directory: $SOURCE_DIR" | tee -a "$INIT_LOG"
      
      if [ -d "$SOURCE_DIR" ]; then
        echo "üìÇ Source directory exists, checking state..." | tee -a "$INIT_LOG"
        cd "$SOURCE_DIR"
        
        if [ -d ".repo" ]; then
          echo "üîç Existing .repo found, validating..." | tee -a "$INIT_LOG"
          
          # Check if repo is corrupted
          if ! repo info >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Corrupted .repo detected, reinitializing..." | tee -a "$INIT_LOG"
            rm -rf .repo
          else
            # Check if manifest URL matches
            CURRENT_URL=$(repo manifest | grep -o 'remote="[^"]*"' | head -1 | cut -d'"' -f2 || echo "unknown")
            if [[ "$CURRENT_URL" != *"$(basename "$MANIFEST_URL" .git)"* ]]; then
              echo "‚ö†Ô∏è Manifest URL mismatch, reinitializing..." | tee -a "$INIT_LOG"
              echo "Current: $CURRENT_URL" | tee -a "$INIT_LOG"
              echo "Expected: $MANIFEST_URL" | tee -a "$INIT_LOG"
              rm -rf .repo
            fi
          fi
        fi
      else
        mkdir -p "$SOURCE_DIR"
        cd "$SOURCE_DIR"
      fi
      
      # Initialize repository if needed
      if [ ! -d ".repo" ]; then
        echo "üîÑ Initializing fresh repository..." | tee -a "../$INIT_LOG"
        
        # Advanced repo init with error handling
        REPO_INIT_CMD="repo init"
        REPO_INIT_CMD="$REPO_INIT_CMD -u '$MANIFEST_URL'"
        REPO_INIT_CMD="$REPO_INIT_CMD -b '$MANIFEST_BRANCH'"
        REPO_INIT_CMD="$REPO_INIT_CMD -m '$MANIFEST_NAME'"
        REPO_INIT_CMD="$REPO_INIT_CMD --depth=1"
        REPO_INIT_CMD="$REPO_INIT_CMD --no-clone-bundle"
        REPO_INIT_CMD="$REPO_INIT_CMD --current-branch"
        
        echo "Executing: $REPO_INIT_CMD" | tee -a "../$INIT_LOG"
        
        # Retry mechanism for repo init
        for attempt in 1 2 3; do
          echo "Repository initialization attempt $attempt/3..." | tee -a "../$INIT_LOG"
          
          if eval "$REPO_INIT_CMD" 2>&1 | tee -a "../$INIT_LOG"; then
            echo "‚úÖ Repository initialized successfully!" | tee -a "../$INIT_LOG"
            break
          else
            if [ $attempt -eq 3 ]; then
              echo "‚ùå Repository initialization failed after 3 attempts" | tee -a "../$INIT_LOG"
              exit 1
            fi
            echo "‚ö†Ô∏è Attempt $attempt failed, retrying in 10s..." | tee -a "../$INIT_LOG"
            sleep 10
            
            # Clean up for retry
            rm -rf .repo
          fi
        done
      else
        echo "üìÅ Repository already initialized, validating..." | tee -a "../$INIT_LOG"
      fi
      
      # Validate repository state
      echo "üß™ Validating repository state..." | tee -a "../$INIT_LOG"
      
      if ! repo info >/dev/null 2>&1; then
        echo "‚ùå Repository validation failed" | tee -a "../$INIT_LOG"
        exit 1
      fi
      
      # Repository information
      {
        echo "=== REPOSITORY INFORMATION ==="
        echo "Manifest URL: $(repo manifest | grep -o 'remote="[^"]*"' | head -1 || echo 'unknown')"
        echo "Current branch: $(repo info | grep 'Current revision:' | head -1 || echo 'unknown')"
        echo "Repository count: $(find .repo/projects -name "*.git" | wc -l 2>/dev/null || echo 'unknown')"
        echo "Repository size: $(du -sh .repo 2>/dev/null | cut -f1 || echo 'unknown')"
        echo "Initialized: $(date)"
      } | tee -a "../$INIT_LOG"
      
      echo "‚úÖ Source repository initialization complete!" | tee -a "../$INIT_LOG"
      
      # Upload initialization log
      cd ..
      buildkite-agent artifact upload "$INIT_LOG"
    agents:
      queue: "default"
    timeout_in_minutes: 15
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    env:
      MANIFEST_URL: "https://github.com/LineageOS/android.git"
      MANIFEST_BRANCH: "lineage-21.0"
      MANIFEST_NAME: "default.xml"

  - label: ":arrows_counterclockwise: Advanced Source Synchronization"
    key: "sync-source"
    depends_on: "init-source"
    command: |
      set -euo pipefail
      
      echo "üöÄ Advanced Android source synchronization with smart recovery..."
      
      cd android-source
      
      # Configuration
      MAX_JOBS=$(nproc)
      SYNC_JOBS=${SYNC_JOBS:-$MAX_JOBS}
      MAX_RETRIES=5
      NETWORK_TIMEOUT=300
      
      # Create comprehensive sync log
      mkdir -p ../logs
      SYNC_LOG="../logs/source-sync.log"
      
      {
        echo "=== SOURCE SYNCHRONIZATION LOG ==="
        echo "Started: $(date)"
        echo "Sync jobs: $SYNC_JOBS (max: $MAX_JOBS)"
        echo "Max retries: $MAX_RETRIES"
        echo "Network timeout: ${NETWORK_TIMEOUT}s"
        echo ""
      } > "$SYNC_LOG"
      
      # Function to check network connectivity
      check_network() {
        echo "üåê Checking network connectivity..." | tee -a "$SYNC_LOG"
        
        local test_urls=(
          "https://github.com"
          "https://android.googlesource.com"
          "https://source.android.com"
        )
        
        for url in "${test_urls[@]}"; do
          if curl -s --max-time 10 --head "$url" >/dev/null 2>&1; then
            echo "‚úÖ Network OK: $url" | tee -a "$SYNC_LOG"
            return 0
          else
            echo "‚ö†Ô∏è Network issue: $url" | tee -a "$SYNC_LOG"
          fi
        done
        
        echo "‚ùå Network connectivity issues detected" | tee -a "$SYNC_LOG"
        return 1
      }
      
      # Function to monitor sync progress
      monitor_sync_progress() {
        local sync_pid=$1
        local start_time=$(date +%s)
        local last_update_time=$start_time
        local last_size=0
        
        while kill -0 $sync_pid 2>/dev/null; do
          sleep 30
          
          local current_time=$(date +%s)
          local current_size=$(du -sb . 2>/dev/null | cut -f1 || echo "0")
          local elapsed=$((current_time - start_time))
          local since_update=$((current_time - last_update_time))
          
          # Calculate transfer rate
          local size_diff=$((current_size - last_size))
          local rate_bps=$((size_diff / 30))
          local rate_mbps=$((rate_bps / 1024 / 1024))
          
          echo "üìä Sync progress: ${elapsed}s elapsed, ${current_size} bytes, ${rate_mbps}MB/s" | tee -a "$SYNC_LOG"
          
          # Check for stalled sync (no progress for 10 minutes)
          if [ $since_update -gt 600 ] && [ $size_diff -eq 0 ]; then
            echo "‚ö†Ô∏è Sync appears stalled, will restart if process exits" | tee -a "$SYNC_LOG"
          fi
          
          last_size=$current_size
          last_update_time=$current_time
        done
      }
      
      # Function to perform smart sync with recovery
      smart_sync() {
        local attempt=1
        local base_delay=30
        
        while [ $attempt -le $MAX_RETRIES ]; do
          echo "üîÑ Sync attempt $attempt/$MAX_RETRIES..." | tee -a "$SYNC_LOG"
          
          # Check network before attempting sync
          if ! check_network; then
            echo "‚ö†Ô∏è Network issues detected, waiting before retry..." | tee -a "$SYNC_LOG"
            sleep $((base_delay * attempt))
            attempt=$((attempt + 1))
            continue
          fi
          
          # Determine sync strategy based on attempt
          local sync_cmd="repo sync"
          
          if [ $attempt -eq 1 ]; then
            # First attempt: full featured sync
            sync_cmd="$sync_cmd -c -j$SYNC_JOBS --force-sync --no-clone-bundle --no-tags --optimized-fetch --prune"
          elif [ $attempt -eq 2 ]; then
            # Second attempt: reduce parallelism
            local reduced_jobs=$((SYNC_JOBS / 2))
            [ $reduced_jobs -lt 1 ] && reduced_jobs=1
            sync_cmd="$sync_cmd -c -j$reduced_jobs --force-sync --no-clone-bundle --no-tags"
          else
            # Subsequent attempts: minimal parallelism, more conservative
            sync_cmd="$sync_cmd -c -j1 --force-sync --no-clone-bundle"
          fi
          
          echo "Executing: $sync_cmd" | tee -a "$SYNC_LOG"
          
          # Start sync in background and monitor
          timeout $NETWORK_TIMEOUT bash -c "$sync_cmd" 2>&1 | tee -a "$SYNC_LOG" &
          local sync_pid=$!
          
          # Monitor progress in background
          monitor_sync_progress $sync_pid &
          local monitor_pid=$!
          
          # Wait for sync to complete
          if wait $sync_pid; then
            # Kill monitor
            kill $monitor_pid 2>/dev/null || true
            wait $monitor_pid 2>/dev/null || true
            
            echo "‚úÖ Sync completed successfully on attempt $attempt!" | tee -a "$SYNC_LOG"
            return 0
          else
            local exit_code=$?
            
            # Kill monitor
            kill $monitor_pid 2>/dev/null || true
            wait $monitor_pid 2>/dev/null || true
            
            echo "‚ùå Sync failed on attempt $attempt (exit code: $exit_code)" | tee -a "$SYNC_LOG"
            
            # Analyze failure and clean up if necessary
            if [ $exit_code -eq 124 ]; then
              echo "‚è∞ Sync timed out after ${NETWORK_TIMEOUT}s" | tee -a "$SYNC_LOG"
            fi
            
            # Check for corrupted repositories and clean them
            echo "üîç Checking for corrupted repositories..." | tee -a "$SYNC_LOG"
            if repo status | grep -q "error\|fatal\|corrupt"; then
              echo "‚ö†Ô∏è Corrupted repositories detected, cleaning..." | tee -a "$SYNC_LOG"
              repo forall -c 'git reset --hard HEAD; git clean -fdx' 2>&1 | tee -a "$SYNC_LOG" || true
            fi
            
            if [ $attempt -eq $MAX_RETRIES ]; then
              echo "üí• All sync attempts failed!" | tee -a "$SYNC_LOG"
              return 1
            fi
            
            # Progressive backoff delay
            local delay=$((base_delay * attempt))
            echo "‚è±Ô∏è Waiting ${delay}s before retry..." | tee -a "$SYNC_LOG"
            sleep $delay
            
            attempt=$((attempt + 1))
          fi
        done
      }
      
      # Pre-sync validation
      echo "üß™ Pre-sync validation..." | tee -a "$SYNC_LOG"
      
      if ! repo info >/dev/null 2>&1; then
        echo "‚ùå Repository not properly initialized" | tee -a "$SYNC_LOG"
        exit 1
      fi
      
      # Check available disk space
      local available_gb=$(df -BG . | awk 'NR==2 {print int($4)}')
      echo "üíæ Available disk space: ${available_gb}GB" | tee -a "$SYNC_LOG"
      
      if [ $available_gb -lt 150 ]; then
        echo "‚ö†Ô∏è Warning: Low disk space (${available_gb}GB < 150GB)" | tee -a "$SYNC_LOG"
        echo "Sync may fail due to insufficient space" | tee -a "$SYNC_LOG"
      fi
      
      # Record pre-sync state
      {
        echo "=== PRE-SYNC STATE ==="
        echo "Repository count: $(find .repo/projects -name "*.git" | wc -l 2>/dev/null || echo 'unknown')"
        echo "Current size: $(du -sh . 2>/dev/null | cut -f1 || echo 'unknown')"
        echo "Available space: ${available_gb}GB"
        echo ""
      } | tee -a "$SYNC_LOG"
      
      # Perform smart sync
      local sync_start_time=$(date +%s)
      
      if smart_sync; then
        local sync_end_time=$(date +%s)
        local sync_duration=$((sync_end_time - sync_start_time))
        
        # Post-sync validation and statistics
        echo "üìä Post-sync analysis..." | tee -a "$SYNC_LOG"
        
        {
          echo "=== SYNC RESULTS ==="
          echo "Status: SUCCESS"
          echo "Duration: $(date -u -d @$sync_duration +%H:%M:%S)"
          echo "Final size: $(du -sh . 2>/dev/null | cut -f1 || echo 'unknown')"
          echo "Repository count: $(find .repo/projects -name "*.git" | wc -l 2>/dev/null || echo 'unknown')"
          echo "Completed: $(date)"
          echo ""
          
          echo "=== PROJECT STATUS ==="
          repo status | head -20 || echo "Status check failed"
          echo ""
          
          echo "=== SYNC STATISTICS ==="
          echo "Jobs used: $SYNC_JOBS"
          echo "Average speed: $(echo "scale=2; $(du -sb . | cut -f1) / $sync_duration / 1024 / 1024" | bc 2>/dev/null || echo "unknown") MB/s"
          
        } | tee -a "$SYNC_LOG"
        
        echo "‚úÖ Source synchronization completed successfully!" | tee -a "$SYNC_LOG"
      else
        echo "üí• Source synchronization failed after all retry attempts" | tee -a "$SYNC_LOG"
        
        # Upload failure logs for debugging
        cd ..
        buildkite-agent artifact upload "$SYNC_LOG"
        exit 1
      fi
      
      # Upload sync log
      cd ..
      buildkite-agent artifact upload "$SYNC_LOG"
    agents:
      queue: "default"
    timeout_in_minutes: 180
    retry:
      automatic:
        - exit_status: "*"
          limit: 1
    env:
      SYNC_JOBS: "8"

  - label: ":hammer_and_wrench: Enterprise Android ROM Build"
    key: "build-rom"
    depends_on: "sync-source"
    command: |
      set -euo pipefail
      
      echo "üèóÔ∏è Enterprise-grade Android ROM build with advanced monitoring..."
      
      cd android-source
      
      # Build configuration with validation
      TARGET_DEVICE="${TARGET_DEVICE:-generic}"
      BUILD_TYPE="${BUILD_TYPE:-userdebug}"
      BUILD_VARIANT="${BUILD_VARIANT:-lineage}"
      BUILD_JOBS="${BUILD_JOBS:-$(nproc)}"
      
      # Create comprehensive build log
      mkdir -p ../logs
      BUILD_LOG="../logs/rom-build.log"
      
      {
        echo "=== ANDROID ROM BUILD LOG ==="
        echo "Started: $(date)"
        echo "Device: $TARGET_DEVICE"
        echo "Type: $BUILD_TYPE"
        echo "Variant: $BUILD_VARIANT"
        echo "Jobs: $BUILD_JOBS"
        echo "Host: $(hostname)"
        echo ""
      } > "$BUILD_LOG"
      
      # Resource monitoring function
      monitor_resources() {
        local build_pid=$1
        local monitor_interval=60
        local resource_log="../logs/resource-usage.log"
        
        echo "=== RESOURCE MONITORING LOG ===" > "$resource_log"
        
        while kill -0 $build_pid 2>/dev/null; do
          {
            echo "Timestamp: $(date)"
            echo "CPU Usage: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"
            echo "Memory: $(free -h | awk '/^Mem:/ {printf "Used: %s/%s (%.1f%%)\n", $3, $2, $3/$2*100}')"
            echo "Disk: $(df -h . | awk 'NR==2 {printf "Used: %s/%s (%s)\n", $3, $2, $5}')"
            echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
            echo "Active processes: $(ps aux | wc -l)"
            echo "Ccache stats: $(ccache -s | grep "cache hit rate" || echo "N/A")"
            echo "Build output size: $(du -sh ../out 2>/dev/null | cut -f1 || echo "N/A")"
            echo "---"
          } >> "$resource_log"
          
          # Check for resource exhaustion
          local mem_usage=$(free | awk '/^Mem:/ {printf "%.1f", $3/$2*100}')
          local disk_usage=$(df . | awk 'NR==2 {print $5}' | sed 's/%//')
          
          if (( $(echo "$mem_usage > 95" | bc -l) )); then
            echo "üö® CRITICAL: Memory usage critical ($mem_usage%)" | tee -a "$BUILD_LOG"
          fi
          
          if [ "$disk_usage" -gt 90 ]; then
            echo "üö® CRITICAL: Disk usage critical ($disk_usage%)" | tee -a "$BUILD_LOG"
          fi
          
          sleep $monitor_interval
        done
        
        buildkite-agent artifact upload "$resource_log" || true
      }
      
      # Build environment validation
      echo "üß™ Validating build environment..." | tee -a "$BUILD_LOG"
      
      # Check Java version
      JAVA_VERSION=$(java -version 2>&1 | awk -F '"' '/version/ {print $2}')
      echo "Java version: $JAVA_VERSION" | tee -a "$BUILD_LOG"
      
      # Validate build tools
      if ! command -v make &> /dev/null; then
        echo "‚ùå Make not found" | tee -a "$BUILD_LOG"
        exit 1
      fi
      
      # Check available memory
      AVAILABLE_MEM_GB=$(free -g | awk '/^Mem:/ {print $7}')
      if [ "$AVAILABLE_MEM_GB" -lt 8 ]; then
        echo "‚ö†Ô∏è Low available memory: ${AVAILABLE_MEM_GB}GB" | tee -a "$BUILD_LOG"
        # Reduce build jobs if memory is low
        BUILD_JOBS=$((BUILD_JOBS / 2))
        [ $BUILD_JOBS -lt 1 ] && BUILD_JOBS=1
        echo "Reduced build jobs to: $BUILD_JOBS" | tee -a "$BUILD_LOG"
      fi
      
      # Validate source integrity
      echo "üîç Validating source code integrity..." | tee -a "$BUILD_LOG"
      
      if ! repo status >/dev/null 2>&1; then
        echo "‚ùå Source code integrity check failed" | tee -a "$BUILD_LOG"
        exit 1
      fi
      
      # Set up advanced build environment
      echo "‚öôÔ∏è Configuring advanced build environment..." | tee -a "$BUILD_LOG"
      
      # Source build environment
      if ! source build/envsetup.sh 2>&1 | tee -a "$BUILD_LOG"; then
        echo "‚ùå Failed to source build environment" | tee -a "$BUILD_LOG"
        exit 1
      fi
      
      # Configure ccache with optimization
      export USE_CCACHE=1
      export CCACHE_DIR=$PWD/../ccache
      export CCACHE_COMPRESS=1
      export CCACHE_COMPRESSLEVEL=6
      export CCACHE_MAXSIZE=100G
      export CCACHE_SLOPPINESS=time_macros,include_file_mtime,include_file_ctime,file_macro
      
      mkdir -p "$CCACHE_DIR"
      ccache -M "$CCACHE_MAXSIZE"
      ccache -s | tee -a "$BUILD_LOG"
      
      # Device-specific validation
      echo "üì± Device-specific validation for: $TARGET_DEVICE" | tee -a "$BUILD_LOG"
      
      # Check if device is supported
      DEVICE_DIR="device/*/‚äï{TARGET_DEVICE}"
      if ! ls device/*/"$TARGET_DEVICE" >/dev/null 2>&1 && [ "$TARGET_DEVICE" != "generic" ]; then
        echo "‚ö†Ô∏è Device $TARGET_DEVICE not found in device tree" | tee -a "$BUILD_LOG"
        echo "Available devices:" | tee -a "$BUILD_LOG"
        find device -mindepth 2 -maxdepth 2 -type d | head -20 | tee -a "$BUILD_LOG"
        
        if [ "${IGNORE_DEVICE_CHECK:-false}" != "true" ]; then
          echo "‚ùå Set IGNORE_DEVICE_CHECK=true to bypass this check" | tee -a "$BUILD_LOG"
          exit 1
        fi
      fi
      
      # Lunch command with validation
      echo "üéØ Configuring build target..." | tee -a "$BUILD_LOG"
      
      LUNCH_COMBO="${BUILD_VARIANT}_${TARGET_DEVICE}-${BUILD_TYPE}"
      echo "Lunch combo: $LUNCH_COMBO" | tee -a "$BUILD_LOG"
      
      if ! lunch "$LUNCH_COMBO" 2>&1 | tee -a "$BUILD_LOG"; then
        echo "‚ùå Failed to configure build target: $LUNCH_COMBO" | tee -a "$BUILD_LOG"
        echo "Available targets:" | tee -a "$BUILD_LOG"
        lunch 2>&1 | grep -E "^[0-9]+\." | head -20 | tee -a "$BUILD_LOG" || true
        exit 1
      fi
      
      # Pre-build cleanup and optimization
      echo "üßπ Pre-build optimization..." | tee -a "$BUILD_LOG"
      
      # Clean old builds if requested
      if [ "${CLEAN_BUILD:-false}" = "true" ]; then
        echo "Performing clean build..." | tee -a "$BUILD_LOG"
        make clean 2>&1 | tee -a "$BUILD_LOG"
      fi
      
      # Optimize build environment
      export LC_ALL=C
      export USE_NINJA=false  # Some builds are more stable without ninja
      export KBUILD_BUILD_USER="buildkite"
      export KBUILD_BUILD_HOST="$(hostname)"
      
      # Build execution with monitoring
      echo "üöÄ Starting ROM compilation..." | tee -a "$BUILD_LOG"
      
      BUILD_START_TIME=$(date +%s)
      
      # Determine build command based on variant
      if [ "$BUILD_VARIANT" = "lineage" ]; then
        BUILD_CMD="brunch $TARGET_DEVICE"
      elif [ "$BUILD_VARIANT" = "aosp" ]; then
        BUILD_CMD="make -j$BUILD_JOBS otapackage"
      else
        BUILD_CMD="make -j$BUILD_JOBS"
      fi
      
      echo "Build command: $BUILD_CMD" | tee -a "$BUILD_LOG"
      
      # Execute build with monitoring
      (
        echo "Build started at: $(date)"
        echo "Build command: $BUILD_CMD"
        echo "Working directory: $(pwd)"
        echo "Environment variables:"
        env | grep -E "(TARGET_|BUILD_|CCACHE_|USE_)" | sort
        echo "=== BUILD OUTPUT ==="
      ) | tee -a "$BUILD_LOG"
      
      # Start build in background
      $BUILD_CMD 2>&1 | tee -a "$BUILD_LOG" &
      BUILD_PID=$!
      
      # Start resource monitoring
      monitor_resources $BUILD_PID &
      MONITOR_PID=$!
      
      # Wait for build to complete with timeout handling
      BUILD_SUCCESS=false
      if wait $BUILD_PID; then
        BUILD_SUCCESS=true
        echo "‚úÖ Build process completed successfully" | tee -a "$BUILD_LOG"
      else
        BUILD_EXIT_CODE=$?
        echo "‚ùå Build process failed with exit code: $BUILD_EXIT_CODE" | tee -a "$BUILD_LOG"
      fi
      
      # Stop monitoring
      kill $MONITOR_PID 2>/dev/null || true
      wait $MONITOR_PID 2>/dev/null || true
      
      BUILD_END_TIME=$(date +%s)
      BUILD_DURATION=$((BUILD_END_TIME - BUILD_START_TIME))
      
      # Post-build analysis
      echo "üìä Post-build analysis..." | tee -a "$BUILD_LOG"
      
      {
        echo "=== BUILD RESULTS ==="
        echo "Status: $([ "$BUILD_SUCCESS" = true ] && echo "SUCCESS" || echo "FAILED")"
        echo "Duration: $(date -u -d @$BUILD_DURATION +%H:%M:%S)"
        echo "Start time: $(date -d @$BUILD_START_TIME)"
        echo "End time: $(date -d @$BUILD_END_TIME)"
        echo "Final ccache stats:"
        ccache -s
        echo ""
        
        if [ "$BUILD_SUCCESS" = true ]; then
          echo "=== BUILD ARTIFACTS ==="
          OUT_DIR="out/target/product/$TARGET_DEVICE"
          if [ -d "$OUT_DIR" ]; then
            echo "Output directory: $OUT_DIR"
            echo "Artifacts found:"
            find "$OUT_DIR" -name "*.zip" -o -name "*.img" | head -10 || echo "No artifacts found"
            echo "Total output size: $(du -sh out 2>/dev/null | cut -f1 || echo "unknown")"
          fi
        else
          echo "=== BUILD FAILURE ANALYSIS ==="
          echo "Last 50 lines of build log:"
          tail -50 "$BUILD_LOG" | grep -E "(error|Error|ERROR|fail|Fail|FAIL)" || echo "No obvious errors in tail"
        fi
        
      } | tee -a "$BUILD_LOG"
      
      # Upload build logs
      cd ..
      buildkite-agent artifact upload "$BUILD_LOG"
      
      if [ "$BUILD_SUCCESS" != true ]; then
        echo "üí• ROM build failed - check build logs for details"
        exit 1
      fi
      
      echo "üéâ ROM build completed successfully!"
    agents:
      queue: "default"
    timeout_in_minutes: 600
    retry:
      automatic:
        - exit_status: "*"
          limit: 1
    env:
      TARGET_DEVICE: "generic"
      BUILD_TYPE: "userdebug" 
      BUILD_VARIANT: "lineage"
      BUILD_JOBS: "8"
      USE_CCACHE: "1"
      CLEAN_BUILD: "false"
      IGNORE_DEVICE_CHECK: "false"

  - label: ":package: Advanced ROM Artifact Management"
    key: "package-rom"
    depends_on: "build-rom"
    command: |
      set -euo pipefail
      
      echo "üì¶ Advanced ROM artifact packaging and validation..."
      
      TARGET_DEVICE="${TARGET_DEVICE:-generic}"
      BUILD_TYPE="${BUILD_TYPE:-userdebug}"
      BUILD_VARIANT="${BUILD_VARIANT:-lineage}"
      OUT_DIR="android-source/out/target/product/$TARGET_DEVICE"
      
      # Create comprehensive packaging log
      mkdir -p logs
      PACKAGE_LOG="logs/packaging.log"
      
      {
        echo "=== ROM ARTIFACT PACKAGING LOG ==="
        echo "Started: $(date)"
        echo "Device: $TARGET_DEVICE"
        echo "Build Type: $BUILD_TYPE"
        echo "Variant: $BUILD_VARIANT"
        echo "Output Directory: $OUT_DIR"
        echo ""
      } > "$PACKAGE_LOG"
      
      # Validate build output directory
      if [ ! -d "$OUT_DIR" ]; then
        echo "‚ùå Build output directory not found: $OUT_DIR" | tee -a "$PACKAGE_LOG"
        echo "Available directories:" | tee -a "$PACKAGE_LOG"
        find android-source/out -type d -name "product" 2>/dev/null | tee -a "$PACKAGE_LOG" || echo "No product directories found"
        exit 1
      fi
      
      echo "‚úÖ Build output directory validated" | tee -a "$PACKAGE_LOG"
      
      # Create artifacts directory with proper structure
      ARTIFACTS_DIR="artifacts"
      mkdir -p "$ARTIFACTS_DIR"/{roms,images,recovery,logs,tools}
      
      echo "üìä Analyzing build output..." | tee -a "$PACKAGE_LOG"
      
      # Comprehensive artifact discovery
      {
        echo "=== BUILD OUTPUT ANALYSIS ==="
        echo "Output directory size: $(du -sh "$OUT_DIR" 2>/dev/null | cut -f1 || echo "unknown")"
        echo "File count: $(find "$OUT_DIR" -type f | wc -l)"
        echo ""
        
        echo "=== ROM FILES ==="
        find "$OUT_DIR" -name "*.zip" -type f -exec ls -lh {} \; 2>/dev/null || echo "No ROM zip files found"
        echo ""
        
        echo "=== IMAGE FILES ==="
        find "$OUT_DIR" -name "*.img" -type f -exec ls -lh {} \; 2>/dev/null | head -20 || echo "No image files found"
        echo ""
        
        echo "=== OTHER ARTIFACTS ==="
        find "$OUT_DIR" -name "*.json" -o -name "*.xml" -o -name "*.txt" -type f 2>/dev/null | head -10 || echo "No metadata files found"
        
      } | tee -a "$PACKAGE_LOG"
      
      # Smart artifact collection
      echo "üîç Collecting ROM artifacts..." | tee -a "$PACKAGE_LOG"
      
      ARTIFACTS_FOUND=0
      
      # ROM packages (flashable zips)
      while IFS= read -r -d '' file; do
        if [ -f "$file" ]; then
          filename=$(basename "$file")
          echo "üì± ROM Package: $filename ($(du -sh "$file" | cut -f1))" | tee -a "$PACKAGE_LOG"
          cp "$file" "$ARTIFACTS_DIR/roms/"
          ARTIFACTS_FOUND=$((ARTIFACTS_FOUND + 1))
        fi
      done < <(find "$OUT_DIR" -name "*.zip" -type f -print0 2>/dev/null || true)
      
      # Critical images
      IMAGE_TYPES=("boot" "recovery" "system" "vendor" "userdata" "cache" "dtbo" "vbmeta")
      
      for img_type in "${IMAGE_TYPES[@]}"; do
        while IFS= read -r -d '' file; do
          if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo "üíø Image: $filename ($(du -sh "$file" | cut -f1))" | tee -a "$PACKAGE_LOG"
            
            if [[ "$img_type" == "recovery" ]]; then
              cp "$file" "$ARTIFACTS_DIR/recovery/"
            else
              cp "$file" "$ARTIFACTS_DIR/images/"
            fi
            ARTIFACTS_FOUND=$((ARTIFACTS_FOUND + 1))
          fi
        done < <(find "$OUT_DIR" -name "${img_type}.img" -type f -print0 2>/dev/null || true)
      done
      
      # Build metadata and logs
      METADATA_FILES=("build.json" "build-info.json" "build.prop" "recovery.fstab")
      
      for meta_file in "${METADATA_FILES[@]}"; do
        while IFS= read -r -d '' file; do
          if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo "üìã Metadata: $filename" | tee -a "$PACKAGE_LOG"
            cp "$file" "$ARTIFACTS_DIR/logs/"
            ARTIFACTS_FOUND=$((ARTIFACTS_FOUND + 1))
          fi
        done < <(find "$OUT_DIR" -name "$meta_file" -type f -print0 2>/dev/null || true)
      done
      
      echo "üìà Total artifacts collected: $ARTIFACTS_FOUND" | tee -a "$PACKAGE_LOG"
      
      if [ $ARTIFACTS_FOUND -eq 0 ]; then
        echo "‚ö†Ô∏è No artifacts found - this may indicate a build failure" | tee -a "$PACKAGE_LOG"
        echo "Build directory contents:" | tee -a "$PACKAGE_LOG"
        ls -la "$OUT_DIR" | tee -a "$PACKAGE_LOG" || true
      fi
      
      # Generate comprehensive build information
      echo "üìù Generating build metadata..." | tee -a "$PACKAGE_LOG"
      
      cat > "$ARTIFACTS_DIR/build-info.json" << EOF
      {
        "build_info": {
          "build_number": "${BUILDKITE_BUILD_NUMBER:-unknown}",
          "commit": "${BUILDKITE_COMMIT:-unknown}",
          "branch": "${BUILDKITE_BRANCH:-unknown}",
          "build_url": "${BUILDKITE_BUILD_URL:-unknown}",
          "pipeline": "${BUILDKITE_PIPELINE_SLUG:-unknown}"
        },
        "device_info": {
          "device": "$TARGET_DEVICE",
          "build_type": "$BUILD_TYPE",
          "variant": "$BUILD_VARIANT"
        },
        "build_metadata": {
          "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "build_timestamp": $(date +%s),
          "builder_host": "$(hostname)",
          "builder_user": "$(whoami)",
          "android_version": "$(grep -o "PLATFORM_VERSION.*" android-source/build/core/version_defaults.mk 2>/dev/null | head -1 || echo "unknown")"
        },
        "artifacts": {
          "total_count": $ARTIFACTS_FOUND,
          "rom_packages": $(find "$ARTIFACTS_DIR/roms" -name "*.zip" 2>/dev/null | wc -l),
          "images": $(find "$ARTIFACTS_DIR/images" -name "*.img" 2>/dev/null | wc -l),
          "recovery": $(find "$ARTIFACTS_DIR/recovery" -name "*.img" 2>/dev/null | wc -l)
        },
        "build_environment": {
          "ccache_stats": "$(ccache -s 2>/dev/null | grep "cache hit rate" || echo "N/A")",
          "java_version": "$(java -version 2>&1 | head -1 || echo "unknown")",
          "build_tools": "$(make --version 2>&1 | head -1 || echo "unknown")"
        }
      }
      EOF
      
      # Generate checksums with validation
      echo "üîê Generating and validating checksums..." | tee -a "$PACKAGE_LOG"
      
      find "$ARTIFACTS_DIR" -name "*.zip" -o -name "*.img" | while read -r file; do
        if [ -f "$file" ]; then
          echo "Checksumming: $(basename "$file")" | tee -a "$PACKAGE_LOG"
          
          # Generate multiple hash types for security
          md5sum "$file" > "${file}.md5"
          sha256sum "$file" > "${file}.sha256"
          sha512sum "$file" > "${file}.sha512"
          
          # Validate checksums immediately
          if md5sum -c "${file}.md5" >/dev/null 2>&1; then
            echo "‚úÖ MD5 checksum verified for $(basename "$file")" | tee -a "$PACKAGE_LOG"
          else
            echo "‚ùå MD5 checksum failed for $(basename "$file")" | tee -a "$PACKAGE_LOG"
          fi
        fi
      done
      
      # Create installation instructions
      cat > "$ARTIFACTS_DIR/INSTALLATION.md" << 'EOF'
      # ROM Installation Instructions
      
      ## Prerequisites
      - Unlocked bootloader
      - Custom recovery (TWRP recommended)
      - USB debugging enabled
      - ADB and Fastboot tools installed
      
      ## Installation Steps
      
      ### Method 1: Recovery Flash (Recommended)
      1. Download the ROM zip file from the artifacts
      2. Boot into recovery mode
      3. Wipe system, data, cache, and dalvik cache
      4. Flash the ROM zip file
      5. Flash GApps if desired
      6. Reboot system
      
      ### Method 2: Fastboot Flash (Advanced)
      1. Boot into fastboot mode
      2. Flash individual image files:
         ```bash
         fastboot flash boot boot.img
         fastboot flash system system.img
         fastboot flash vendor vendor.img
         fastboot flash recovery recovery.img
         ```
      3. Reboot system
      
      ## Verification
      - Check build date in Settings > About Phone
      - Verify ROM version matches build info
      - Test basic functionality before daily use
      
      ## Support
      - Check build logs if issues occur
      - Verify checksums before flashing
      - Create backup before installation
      EOF
      
      # Final artifact summary
      echo "üìä Final artifact summary..." | tee -a "$PACKAGE_LOG"
      
      {
        echo "=== FINAL ARTIFACT SUMMARY ==="
        echo "Packaging completed: $(date)"
        echo ""
        echo "Directory structure:"
        find "$ARTIFACTS_DIR" -type f | sort | while read -r file; do
          echo "  $(basename "$file") ($(du -sh "$file" | cut -f1))"
        done
        echo ""
        echo "Total artifacts size: $(du -sh "$ARTIFACTS_DIR" | cut -f1)"
        echo "Checksum files created: $(find "$ARTIFACTS_DIR" -name "*.md5" -o -name "*.sha*" | wc -l)"
        
      } | tee -a "$PACKAGE_LOG"
      
      # Validate final package
      if [ $ARTIFACTS_FOUND -gt 0 ]; then
        echo "‚úÖ ROM artifact packaging completed successfully!" | tee -a "$PACKAGE_LOG"
      else
        echo "‚ùå ROM artifact packaging completed but no artifacts were found!" | tee -a "$PACKAGE_LOG"
        exit 1
      fi
      
      # Upload packaging log
      buildkite-agent artifact upload "$PACKAGE_LOG"
    agents:
      queue: "default"
    timeout_in_minutes: 45
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    env:
      TARGET_DEVICE: "generic"
      BUILD_TYPE: "userdebug" 
      BUILD_VARIANT: "lineage"

  - label: ":arrow_up: Enterprise Artifact Distribution"
    key: "upload-artifacts"
    depends_on: "package-rom"
    command: |
      set -euo pipefail
      
      echo "üöÄ Enterprise-grade artifact distribution and validation..."
      
      # Create upload log
      mkdir -p logs
      UPLOAD_LOG="logs/artifact-upload.log"
      
      {
        echo "=== ARTIFACT UPLOAD LOG ==="
        echo "Started: $(date)"
        echo "Build: ${BUILDKITE_BUILD_NUMBER:-unknown}"
        echo "Pipeline: ${BUILDKITE_PIPELINE_SLUG:-unknown}"
        echo ""
      } > "$UPLOAD_LOG"
      
      # Pre-upload validation
      echo "üîç Pre-upload artifact validation..." | tee -a "$UPLOAD_LOG"
      
      ARTIFACTS_DIR="artifacts"
      if [ ! -d "$ARTIFACTS_DIR" ]; then
        echo "‚ùå Artifacts directory not found!" | tee -a "$UPLOAD_LOG"
        exit 1
      fi
      
      # Count and validate artifacts
      ROM_COUNT=$(find "$ARTIFACTS_DIR" -name "*.zip" | wc -l)
      IMG_COUNT=$(find "$ARTIFACTS_DIR" -name "*.img" | wc -l)
      CHECKSUM_COUNT=$(find "$ARTIFACTS_DIR" -name "*.md5" -o -name "*.sha*" | wc -l)
      TOTAL_SIZE=$(du -sh "$ARTIFACTS_DIR" | cut -f1)
      
      {
        echo "=== UPLOAD VALIDATION ==="
        echo "ROM packages: $ROM_COUNT"
        echo "Image files: $IMG_COUNT"
        echo "Checksum files: $CHECKSUM_COUNT"
        echo "Total size: $TOTAL_SIZE"
        echo ""
      } | tee -a "$UPLOAD_LOG"
      
      if [ $ROM_COUNT -eq 0 ] && [ $IMG_COUNT -eq 0 ]; then
        echo "‚ö†Ô∏è No ROM or image files found to upload!" | tee -a "$UPLOAD_LOG"
        echo "Directory contents:" | tee -a "$UPLOAD_LOG"
        find "$ARTIFACTS_DIR" -type f | tee -a "$UPLOAD_LOG"
      fi
      
      # Upload function with retry logic
      upload_with_retry() {
        local pattern="$1"
        local description="$2"
        local max_attempts=3
        local attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Uploading $description (attempt $attempt/$max_attempts)..." | tee -a "$UPLOAD_LOG"
          
          if buildkite-agent artifact upload "$pattern" 2>&1 | tee -a "$UPLOAD_LOG"; then
            echo "‚úÖ $description uploaded successfully" | tee -a "$UPLOAD_LOG"
            return 0
          else
            echo "‚ùå Upload failed for $description" | tee -a "$UPLOAD_LOG"
            if [ $attempt -eq $max_attempts ]; then
              echo "üí• All upload attempts failed for $description" | tee -a "$UPLOAD_LOG"
              return 1
            fi
            attempt=$((attempt + 1))
            sleep 10
          fi
        done
      }
      
      # Upload ROM packages
      if [ $ROM_COUNT -gt 0 ]; then
        echo "üì± Uploading ROM packages..." | tee -a "$UPLOAD_LOG"
        upload_with_retry "artifacts/roms/*.zip" "ROM packages"
      fi
      
      # Upload system images
      if [ $IMG_COUNT -gt 0 ]; then
        echo "üíø Uploading system images..." | tee -a "$UPLOAD_LOG"
        upload_with_retry "artifacts/images/*.img" "system images"
        upload_with_retry "artifacts/recovery/*.img" "recovery images"
      fi
      
      # Upload checksums and metadata
      echo "üîê Uploading checksums and metadata..." | tee -a "$UPLOAD_LOG"
      upload_with_retry "artifacts/*.json" "build metadata"
      upload_with_retry "artifacts/**/*.md5" "MD5 checksums"
      upload_with_retry "artifacts/**/*.sha*" "SHA checksums"
      
      # Upload documentation
      echo "üìö Uploading documentation..." | tee -a "$UPLOAD_LOG"
      upload_with_retry "artifacts/*.md" "installation instructions"
      
      # Upload all logs
      echo "üìÑ Uploading build logs..." | tee -a "$UPLOAD_LOG"
      upload_with_retry "logs/*.log" "build logs"
      
      # Final upload summary
      {
        echo "=== UPLOAD SUMMARY ==="
        echo "Upload completed: $(date)"
        echo "Artifacts uploaded:"
        buildkite-agent artifact search "*" | head -20 || echo "Could not list artifacts"
        echo ""
        echo "Download links will be available in the Buildkite artifacts tab"
        echo "Total upload size: $TOTAL_SIZE"
        
      } | tee -a "$UPLOAD_LOG"
      
      echo "‚úÖ All artifacts uploaded successfully!" | tee -a "$UPLOAD_LOG"
      
      # Upload the upload log itself
      buildkite-agent artifact upload "$UPLOAD_LOG"
    agents:
      queue: "default"
    timeout_in_minutes: 60
    retry:
      automatic:
        - exit_status: "*"
          limit: 2

  - label: ":trophy: Build Success & Analytics"
    depends_on: "upload-artifacts"
    command: |
      set -euo pipefail
      
      echo "üéâ Android ROM build pipeline completed successfully!"
      
      # Create final report
      mkdir -p logs
      FINAL_REPORT="logs/build-final-report.log"
      
      {
        echo "=========================================="
        echo "      ANDROID ROM BUILD COMPLETE"
        echo "=========================================="
        echo ""
        echo "üèÜ BUILD INFORMATION"
        echo "Build Number: ${BUILDKITE_BUILD_NUMBER:-unknown}"
        echo "Build URL: ${BUILDKITE_BUILD_URL:-unknown}"
        echo "Pipeline: ${BUILDKITE_PIPELINE_SLUG:-unknown}"
        echo "Commit: ${BUILDKITE_COMMIT:-unknown}"
        echo "Branch: ${BUILDKITE_BRANCH:-unknown}"
        echo "Triggered by: ${BUILDKITE_BUILD_CREATOR:-unknown}"
        echo ""
        echo "üì± DEVICE CONFIGURATION"
        echo "Target Device: ${TARGET_DEVICE:-generic}"
        echo "Build Type: ${BUILD_TYPE:-userdebug}"
        echo "Build Variant: ${BUILD_VARIANT:-lineage}"
        echo ""
        echo "‚è±Ô∏è TIMING INFORMATION"
        echo "Build started: ${BUILDKITE_BUILD_CREATED_AT:-unknown}"
        echo "Build completed: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo ""
        echo "üéØ QUICK LINKS"
        echo "Artifacts: ${BUILDKITE_BUILD_URL:-unknown}#artifacts"
        echo "Build logs: ${BUILDKITE_BUILD_URL:-unknown}#logs"
        echo ""
        echo "üì¶ WHAT'S INCLUDED"
        echo "‚úÖ Flashable ROM package (.zip)"
        echo "‚úÖ Individual partition images (.img)"
        echo "‚úÖ Recovery image (if built)"
        echo "‚úÖ Build metadata and checksums"
        echo "‚úÖ Installation instructions"
        echo "‚úÖ Complete build logs"
        echo ""
        echo "üîê SECURITY"
        echo "‚úÖ MD5, SHA256, and SHA512 checksums provided"
        echo "‚úÖ Build reproducibility information included"
        echo "‚úÖ Build environment details logged"
        echo ""
        echo "üìã NEXT STEPS"
        echo "1. Download artifacts from the Artifacts tab"
        echo "2. Verify checksums before flashing"
        echo "3. Follow installation instructions"
        echo "4. Create a backup before flashing"
        echo "5. Test thoroughly before daily use"
        echo ""
        echo "üÜò SUPPORT"
        echo "- Check build logs if you encounter issues"
        echo "- Verify your device is supported"
        echo "- Ensure bootloader is unlocked"
        echo "- Use appropriate recovery (TWRP recommended)"
        echo ""
        echo "=========================================="
        echo "        BUILD COMPLETED SUCCESSFULLY!"
        echo "=========================================="
        
      } | tee "$FINAL_REPORT"
      
      # Display key information
      cat "$FINAL_REPORT"
      
      # Upload final report
      buildkite-agent artifact upload "$FINAL_REPORT"
      
      # Analytics and notifications (if configured)
      if [ -n "${SLACK_WEBHOOK:-}" ]; then
        echo "üì¢ Sending Slack notification..."
        curl -X POST -H 'Content-type: application/json' \
          --data "{
            \"text\": \"üéâ Android ROM build completed!\",
            \"attachments\": [{
              \"color\": \"good\",
              \"fields\": [
                {\"title\": \"Device\", \"value\": \"${TARGET_DEVICE:-generic}\", \"short\": true},
                {\"title\": \"Variant\", \"value\": \"${BUILD_VARIANT:-lineage}\", \"short\": true},
                {\"title\": \"Build\", \"value\": \"#${BUILDKITE_BUILD_NUMBER:-unknown}\", \"short\": true},
                {\"title\": \"Branch\", \"value\": \"${BUILDKITE_BRANCH:-unknown}\", \"short\": true}
              ],
              \"actions\": [{
                \"type\": \"button\",
                \"text\": \"Download Artifacts\",
                \"url\": \"${BUILDKITE_BUILD_URL:-unknown}#artifacts\"
              }]
            }]
          }" \
          "${SLACK_WEBHOOK}" || echo "Slack notification failed"
      fi
      
      echo ""
      echo "üöÄ Your Android ROM is ready!"
      echo "üì≤ Download from: ${BUILDKITE_BUILD_URL:-unknown}#artifacts"
      echo ""
    agents:
      queue: "default"
    env:
      TARGET_DEVICE: "generic"
      BUILD_TYPE: "userdebug"
      BUILD_VARIANT: "lineage" 