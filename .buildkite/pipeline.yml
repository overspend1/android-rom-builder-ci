# üöÄ Enterprise Android ROM Build Pipeline
# The most advanced Buildkite pipeline for Android ROM development
# 
# Features:
# - Enterprise-grade error detection & auto-recovery
# - Advanced resource monitoring & optimization  
# - Intelligent retry logic with progressive backoff
# - Comprehensive build analytics & reporting
# - Multi-device support with automatic detection
# - Real-time notifications & status updates
# - Dynamic pipeline generation
# - Artifact management with versioning
# - Performance optimization & caching

env:
  # Build Environment
  TERM: "xterm-256color"
  DEBIAN_FRONTEND: "noninteractive"
  LC_ALL: "C.UTF-8"
  
  # Pipeline Configuration
  PIPELINE_VERSION: "3.0.0"
  BUILD_TIMEOUT: "10800"
  MAX_PARALLEL_JOBS: "16"
  
  # Android Build Configuration
  TARGET_DEVICE: "${TARGET_DEVICE:-lineage_generic_x86_64-userdebug}"
  BUILD_VARIANT: "${BUILD_VARIANT:-userdebug}"
  BUILD_TYPE: "${BUILD_TYPE:-lineage}"
  
  # Repository Configuration
  MANIFEST_URL: "${MANIFEST_URL:-https://github.com/LineageOS/android.git}"
  MANIFEST_BRANCH: "${MANIFEST_BRANCH:-lineage-21.0}"
  
  # Device Tree Configuration
  DEVICE_TREE_URL: "${DEVICE_TREE_URL:-}"
  DEVICE_TREE_BRANCH: "${DEVICE_TREE_BRANCH:-lineage-21.0}"
  KERNEL_SOURCE_URL: "${KERNEL_SOURCE_URL:-}"
  KERNEL_SOURCE_BRANCH: "${KERNEL_SOURCE_BRANCH:-lineage-21.0}"
  VENDOR_TREE_URL: "${VENDOR_TREE_URL:-}"
  VENDOR_TREE_BRANCH: "${VENDOR_TREE_BRANCH:-lineage-21.0}"
  
  # Performance Tuning
  USE_CCACHE: "1"
  CCACHE_SIZE: "200G"
  BUILD_JOBS: "${BUILD_JOBS:-}"
  SYNC_JOBS: "${SYNC_JOBS:-}"
  
  # Quality Control
  CLEAN_BUILD: "${CLEAN_BUILD:-false}"
  IGNORE_DEVICE_CHECK: "${IGNORE_DEVICE_CHECK:-false}"
  
  # Notifications
  SLACK_WEBHOOK: "${SLACK_WEBHOOK:-}"
  
  # Security
  ENABLE_SIGNING: "${ENABLE_SIGNING:-false}"
  SIGNING_KEY_PATH: "${SIGNING_KEY_PATH:-}"

steps:
  - label: ":mag: Enterprise System Diagnostics & Validation"
    key: "system-diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîç Running comprehensive enterprise system diagnostics..."
      
      # Create logs directory
      mkdir -p logs
      
      # System information with proper variable escaping
      {
        echo "=== SYSTEM INFORMATION ==="
        uname -a
        lsb_release -a 2>/dev/null || cat /etc/os-release
        
        echo -e "\n=== HARDWARE SPECS ==="
        echo "CPU Cores: $$(nproc)"
        echo "CPU Info: $$(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
        echo "Total RAM: $$(free -h | awk '/^Mem:/ {print $$$$2}')"
        echo "Available RAM: $$(free -h | awk '/^Mem:/ {print $$$$7}')"
        
        echo -e "\n=== DISK SPACE ==="
        df -h / /tmp 2>/dev/null || true
        
        echo -e "\n=== NETWORK ==="
        curl -s --max-time 10 https://httpbin.org/ip || echo "Network test failed"
        
        echo -e "\n=== BUILD TOOLS ==="
        java -version 2>&1 || echo "Java not found"
        python3 --version 2>&1 || echo "Python3 not found"
        git --version 2>&1 || echo "Git not found"
        
      } | tee logs/system-diagnostics.log
      
      # Validate minimum requirements with proper variable handling
      echo "üß™ Validating enterprise build requirements..."
      
      CORES=$$(nproc)
      RAM_GB=$$(free -g | awk '/^Mem:/ {print $$$$2}')
      DISK_GB=$$(df -BG / | awk 'NR==2 {print int($$$$4)}')
      
      echo "üìä Resource Summary:"
      echo "  CPU Cores: $$CORES (minimum: 8)"
      echo "  RAM: $${RAM_GB}GB (minimum: 32GB)"
      echo "  Disk Space: $${DISK_GB}GB (minimum: 500GB)"
      
      # Generate performance baseline
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"cpu_cores\": $$CORES,"
        echo "  \"ram_gb\": $$RAM_GB,"
        echo "  \"disk_gb\": $$DISK_GB,"
        echo "  \"cpu_model\": \"$$(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)\","
        echo "  \"kernel\": \"$$(uname -r)\","
        echo "  \"os\": \"$$(lsb_release -ds 2>/dev/null || cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '\"')\""
        echo "}"
      } > logs/hardware-report.json
      
      # Check requirements and fail if insufficient
      ERRORS=0
      
      if [ "$$CORES" -lt 8 ]; then
        echo "‚ùå Insufficient CPU cores: $$CORES < 8"
        ERRORS=$$((ERRORS + 1))
      fi
      
      if [ "$$RAM_GB" -lt 32 ]; then
        echo "‚ö†Ô∏è Warning: Low RAM: $${RAM_GB}GB < 32GB (may cause build failures)"
      fi
      
      if [ "$$DISK_GB" -lt 500 ]; then
        echo "‚ùå Insufficient disk space: $${DISK_GB}GB < 500GB"
        ERRORS=$$((ERRORS + 1))
      fi
      
      if [ "$$ERRORS" -gt 0 ]; then
        echo "üí• $$ERRORS critical errors found! Build cannot proceed."
        echo "Please upgrade your build infrastructure."
        exit 1
      fi
      
      echo "‚úÖ All enterprise requirements satisfied!"
      
      # Upload diagnostics
      buildkite-agent artifact upload "logs/system-diagnostics.log"
      buildkite-agent artifact upload "logs/hardware-report.json"
    agents:
      queue: "default"
    timeout_in_minutes: 10
    retry:
      automatic:
        - exit_status: "*"
          limit: 2
    artifact_paths:
      - "logs/system-diagnostics.log"
      - "logs/hardware-report.json"

  - label: ":package: Enterprise Dependency Management"
    key: "dependency-management"
    depends_on: "system-diagnostics"
    command: |
      set -euo pipefail
      
      echo "üîß Enterprise Android build dependency installation..."
      
      # Create installation log
      mkdir -p logs
      INSTALL_LOG="logs/dependency-install.log"
      
      # Function for intelligent retry logic
      retry_command() {
        local max_attempts=5
        local delay=10
        local command="$$1"
        local attempt=1
        
        until [ $$attempt -gt $$max_attempts ]; do
          echo "üîÑ Attempt $$attempt/$$max_attempts: $$command"
          if eval "$$command"; then
            echo "‚úÖ Command succeeded: $$command"
            return 0
          else
            echo "‚ùå Command failed, retrying in $${delay}s..."
            sleep $$delay
            delay=$$((delay * 2))
            attempt=$$((attempt + 1))
          fi
        done
        
        echo "üí• Command failed after $$max_attempts attempts: $$command"
        return 1
      }
      
      # Log installation start
      {
        echo "=== ENTERPRISE DEPENDENCY INSTALLATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Host: $$(hostname)"
        echo "User: $$(whoami)"
        echo "Working Directory: $$(pwd)"
        echo ""
      } > "$$INSTALL_LOG"
      
      # Validate OS compatibility
      if ! command -v apt-get &> /dev/null; then
        echo "‚ùå This pipeline requires Ubuntu/Debian with apt-get"
        exit 1
      fi
      
      # Update package lists with retry
      echo "üì¶ Updating package repositories..."
      retry_command "sudo apt-get update -qq" 2>&1 | tee -a "$$INSTALL_LOG"
      
      # Install core dependencies in optimized batches
      echo "üõ†Ô∏è Installing Android build dependencies..."
      
      # Core system tools
      CORE_PACKAGES=(
        "git" "curl" "wget" "python3" "python3-pip" "python-is-python3"
        "build-essential" "libc6-dev" "libssl-dev" "pkg-config"
      )
      
      # Java development environment
      JAVA_PACKAGES=(
        "openjdk-8-jdk" "openjdk-11-jdk" "openjdk-17-jdk"
      )
      
      # Android-specific libraries
      ANDROID_PACKAGES=(
        "libncurses5" "libncurses5-dev" "lib32ncurses5-dev"
        "libreadline-dev" "lib32readline-dev" "libtinfo5"
        "libxml2-utils" "xsltproc" "zip" "unzip"
        "zlib1g-dev" "lib32z1-dev" "liblz4-tool"
      )
      
      # Build optimization tools
      BUILD_PACKAGES=(
        "ccache" "schedtool" "bc" "bison" "flex"
        "g++-multilib" "gcc-multilib" "rsync"
        "squashfs-tools" "python3-mako" "libffi-dev"
      )
      
      # Install packages in batches
      for package_set in "CORE_PACKAGES[@]" "JAVA_PACKAGES[@]" "ANDROID_PACKAGES[@]" "BUILD_PACKAGES[@]"; do
        eval "packages=(\$${package_set})"
        echo "üì• Installing package set: $${packages[*]}"
        retry_command "sudo apt-get install -y $${packages[*]}" 2>&1 | tee -a "$$INSTALL_LOG"
      done
      
      # Configure Java environment for Android builds
      echo "‚òï Configuring Java environment..."
      export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
      export PATH=$$JAVA_HOME/bin:$$PATH
      
      # Install repo tool with verification
      echo "üîÑ Installing Google repo tool..."
      REPO_URL="https://storage.googleapis.com/git-repo-downloads/repo"
      
      retry_command "curl -o /tmp/repo '$$REPO_URL'" 2>&1 | tee -a "$$INSTALL_LOG"
      
      # Verify repo download
      if [ ! -f /tmp/repo ] || [ ! -s /tmp/repo ]; then
        echo "‚ùå Failed to download repo tool"
        exit 1
      fi
      
      sudo mv /tmp/repo /usr/local/bin/repo
      sudo chmod a+x /usr/local/bin/repo
      
      # Verify repo installation
      if ! repo --version &>/dev/null; then
        echo "‚ùå Repo tool installation failed"
        exit 1
      fi
      
      echo "‚úÖ Repo tool installed: $$(repo --version | head -1)"
      
      # Configure ccache for build acceleration
      echo "üöÄ Configuring ccache for optimal performance..."
      export USE_CCACHE=1
      export CCACHE_DIR="$$HOME/.ccache"
      mkdir -p "$$CCACHE_DIR"
      ccache -M $$CCACHE_SIZE
      ccache -s
      
      # Configure git for repo operations
      echo "üîß Configuring git environment..."
      git config --global user.email "$${GIT_EMAIL:-android-builder@buildkite.local}"
      git config --global user.name "$${GIT_NAME:-Buildkite Android Builder}"
      git config --global color.ui auto
      git config --global init.defaultBranch main
      
      # Generate installation verification report
      {
        echo "=== INSTALLATION VERIFICATION ==="
        echo "Java: $$(java -version 2>&1 | head -1)"
        echo "Python: $$(python3 --version)"
        echo "Git: $$(git --version)"
        echo "Repo: $$(repo --version | head -1)"
        echo "Make: $$(make --version | head -1)"
        echo "GCC: $$(gcc --version | head -1)"
        echo "Ccache: $$(ccache --version | head -1)"
        echo "Ccache stats: $$(ccache -s | grep 'cache size')"
        echo "Completed: $$(date -Iseconds)"
      } | tee -a "$$INSTALL_LOG"
      
      # Create verification report in JSON
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"java_version\": \"$$(java -version 2>&1 | head -1 | tr -d '\"')\","
        echo "  \"python_version\": \"$$(python3 --version)\","
        echo "  \"git_version\": \"$$(git --version)\","
        echo "  \"repo_version\": \"$$(repo --version | head -1)\","
        echo "  \"ccache_size\": \"$$CCACHE_SIZE\","
        echo "  \"status\": \"success\""
        echo "}"
      } > logs/package-verification.json
      
      echo "‚úÖ All enterprise dependencies installed and verified!"
      
      # Upload logs
      buildkite-agent artifact upload "$$INSTALL_LOG"
      buildkite-agent artifact upload "logs/package-verification.json"
    agents:
      queue: "default"
    timeout_in_minutes: 45
    retry:
      automatic:
        - exit_status: "*"
          limit: 3
    artifact_paths:
      - "logs/dependency-install.log"
      - "logs/package-verification.json"


  - label: ":octocat: Enterprise Repository Initialization"
    key: "repo-init"
    depends_on: "dependency-management"
    command: |
      set -euo pipefail
      
      echo "üöÄ Enterprise Android repository initialization..."
      
      # Create workspace and logs
      mkdir -p android-workspace logs
      cd android-workspace
      
      # Initialize timing and monitoring
      START_TIME=$$(date +%s)
      INIT_LOG="../logs/repo-init.log"
      
      {
        echo "=== ANDROID REPOSITORY INITIALIZATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Manifest URL: $$MANIFEST_URL"
        echo "Manifest Branch: $$MANIFEST_BRANCH"
        echo "Target Device: $$TARGET_DEVICE"
        echo ""
      } > "$$INIT_LOG"
      
      # Validate manifest URL accessibility
      echo "üîç Validating manifest repository..."
      if ! curl -s --head --max-time 30 "$$MANIFEST_URL" | grep -q "200 OK"; then
        echo "‚ùå Manifest URL not accessible: $$MANIFEST_URL"
        exit 1
      fi
      
      echo "‚úÖ Manifest repository accessible"
      
      # Initialize repo with comprehensive error handling
      echo "üìã Initializing Android repository..."
      
      # Function for repo operations with retry
      repo_operation() {
        local operation="$$1"
        local max_attempts=3
        local attempt=1
        
        while [ $$attempt -le $$max_attempts ]; do
          echo "üîÑ Repo $$operation attempt $$attempt/$$max_attempts"
          
          if [ "$$operation" = "init" ]; then
            if repo init -u "$$MANIFEST_URL" -b "$$MANIFEST_BRANCH" --depth=1 2>&1 | tee -a "$$INIT_LOG"; then
              echo "‚úÖ Repo initialization successful"
              return 0
            fi
          fi
          
          echo "‚ùå Repo $$operation failed, attempt $$attempt/$$max_attempts"
          
          if [ $$attempt -lt $$max_attempts ]; then
            echo "üßπ Cleaning up for retry..."
            rm -rf .repo
            sleep $$((attempt * 10))
          fi
          
          attempt=$$((attempt + 1))
        done
        
        echo "üí• Repo $$operation failed after $$max_attempts attempts"
        return 1
      }
      
      # Execute repo initialization with retry
      if ! repo_operation "init"; then
        echo "üí• Repository initialization failed!"
        exit 1
      fi
      
      # Validate repo initialization
      if [ ! -d .repo ]; then
        echo "‚ùå Repository initialization incomplete - .repo directory missing"
        exit 1
      fi
      
      # Generate repository analysis
      {
        echo "=== REPOSITORY ANALYSIS ==="
        echo "Repo version: $$(repo --version | head -1)"
        echo "Manifest projects: $$(repo list | wc -l)"
        echo "Repo directory size: $$(du -sh .repo | cut -f1)"
        echo "Initialization time: $$(($(date +%s) - START_TIME))s"
      } | tee -a "$$INIT_LOG"
      
      # Create repository state report
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"manifest_url\": \"$$MANIFEST_URL\","
        echo "  \"manifest_branch\": \"$$MANIFEST_BRANCH\","
        echo "  \"repo_version\": \"$$(repo --version | head -1)\","
        echo "  \"project_count\": $$(repo list | wc -l),"
        echo "  \"initialization_time_seconds\": $$(($(date +%s) - START_TIME)),"
        echo "  \"status\": \"initialized\""
        echo "}"
      } > ../logs/manifest-info.json
      
      echo "‚úÖ Android repository initialized successfully!"
      
      # Upload artifacts from parent directory
      cd ..
      buildkite-agent artifact upload "$$INIT_LOG"
      buildkite-agent artifact upload "logs/manifest-info.json"
    agents:
      queue: "default"
    timeout_in_minutes: 30
    retry:
      automatic:
        - exit_status: "*"
          limit: 3
    artifact_paths:
      - "logs/repo-init.log"
      - "logs/manifest-info.json"
    concurrency_group: "repo-init"
    concurrency: 1

  - label: ":arrows_counterclockwise: Enterprise Source Synchronization"
    key: "source-sync"
    depends_on: "repo-init"
    command: |
      set -euo pipefail
      
      echo "üîÑ Enterprise Android source synchronization..."
      
      cd android-workspace
      
      # Initialize sync monitoring
      START_TIME=$$(date +%s)
      SYNC_LOG="../logs/sync-$$(date +%Y%m%d-%H%M%S).log"
      
      {
        echo "=== ENTERPRISE SOURCE SYNCHRONIZATION ==="
        echo "Started: $$(date -Iseconds)"
        echo "Sync Jobs: $${SYNC_JOBS:-8}"
        echo "Working Directory: $$(pwd)"
        echo ""
      } > "$$SYNC_LOG"
      
      # Determine optimal sync job count based on system resources
      if [ -z "$$SYNC_JOBS" ]; then
        CORES=$$(nproc)
        if [ "$$CORES" -ge 16 ]; then
          SYNC_JOBS=16
        elif [ "$$CORES" -ge 8 ]; then
          SYNC_JOBS=8
        else
          SYNC_JOBS=4
        fi
        echo "üîß Auto-detected sync jobs: $$SYNC_JOBS (based on $$CORES cores)"
      fi
      
      # Enhanced sync function with progress monitoring
      enterprise_sync() {
        local attempt=1
        local max_attempts=5
        local base_delay=60
        
        while [ $$attempt -le $$max_attempts ]; do
          echo "üîÑ Sync attempt $$attempt/$$max_attempts (using $$SYNC_JOBS jobs)"
          
          # Start sync with comprehensive monitoring
          {
            echo "=== SYNC ATTEMPT $$attempt ==="
            echo "Started: $$(date -Iseconds)"
            echo "Command: repo sync -c -j$$SYNC_JOBS --force-sync --no-tags --no-clone-bundle --optimized-fetch --prune"
          } | tee -a "$$SYNC_LOG"
          
          # Execute sync with timeout and monitoring
          if timeout 7200 repo sync -c -j"$$SYNC_JOBS" --force-sync --no-tags --no-clone-bundle --optimized-fetch --prune 2>&1 | tee -a "$$SYNC_LOG"; then
            echo "‚úÖ Source synchronization completed successfully!"
            
            # Generate sync completion report
            {
              echo "=== SYNC COMPLETION REPORT ==="
              echo "Completed: $$(date -Iseconds)"
              echo "Total sync time: $$(($(date +%s) - START_TIME))s"
              echo "Projects synced: $$(repo list | wc -l)"
              echo "Repository size: $$(du -sh . | cut -f1)"
            } | tee -a "$$SYNC_LOG"
            
            return 0
          else
            SYNC_EXIT_CODE=$$?
            echo "‚ùå Sync attempt $$attempt failed with exit code: $$SYNC_EXIT_CODE"
            
            # Analyze failure and attempt recovery
            if [ $$SYNC_EXIT_CODE -eq 124 ]; then
              echo "‚è∞ Sync timed out - may need to reduce concurrent jobs"
              if [ "$$SYNC_JOBS" -gt 2 ]; then
                SYNC_JOBS=$$((SYNC_JOBS / 2))
                echo "üîß Reducing sync jobs to $$SYNC_JOBS for retry"
              fi
            fi
            
            # Clean up corrupted state if needed
            echo "üßπ Cleaning up potential corruption..."
            repo forall -c 'git reset --hard HEAD; git clean -fd' 2>/dev/null || true
            
            if [ $$attempt -lt $$max_attempts ]; then
              delay=$$((base_delay * attempt))
              echo "‚è≥ Waiting $${delay}s before retry..."
              sleep $$delay
            fi
          fi
          
          attempt=$$((attempt + 1))
        done
        
        echo "üí• All sync attempts failed!"
        return 1
      }
      
      # Execute enterprise sync
      if ! enterprise_sync; then
        echo "üí• Source synchronization failed after all retry attempts!"
        exit 1
      fi
      
      # Verify sync integrity
      echo "üîç Verifying synchronization integrity..."
      
      REPO_STATUS=$$(repo status 2>/dev/null | wc -l)
      if [ "$$REPO_STATUS" -gt 0 ]; then
        echo "‚ö†Ô∏è Warning: $$REPO_STATUS projects have uncommitted changes"
        repo status | head -20 | tee -a "$$SYNC_LOG"
      else
        echo "‚úÖ All projects are clean"
      fi
      
      # Generate comprehensive sync analytics
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"sync_duration_seconds\": $$(($(date +%s) - START_TIME)),"
        echo "  \"sync_jobs_used\": $$SYNC_JOBS,"
        echo "  \"total_projects\": $$(repo list | wc -l),"
        echo "  \"repository_size_mb\": $$(du -sm . | cut -f1),"
        echo "  \"projects_with_changes\": $$REPO_STATUS,"
        echo "  \"status\": \"completed\""
        echo "}"
      } > ../logs/sync-analytics.json
      
      echo "‚úÖ Enterprise source synchronization completed!"
      
      # Clone device-specific trees if specified
      echo "üå≥ Cloning device trees and vendor blobs..."
      
      if [ -n "$$DEVICE_TREE_URL" ]; then
        echo "üì± Cloning device tree from: $$DEVICE_TREE_URL"
        DEVICE_PATH="device/$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        DEVICE_MANUFACTURER="$$(echo "$$DEVICE_PATH" | cut -d'/' -f2)"
        DEVICE_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        
        mkdir -p "device/$$DEVICE_MANUFACTURER"
        if ! git clone "$$DEVICE_TREE_URL" -b "$$DEVICE_TREE_BRANCH" "device/$$DEVICE_MANUFACTURER/$$DEVICE_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone device tree, continuing without it"
        else
          echo "‚úÖ Device tree cloned to device/$$DEVICE_MANUFACTURER/$$DEVICE_NAME"
        fi
      fi
      
      if [ -n "$$KERNEL_SOURCE_URL" ]; then
        echo "üîß Cloning kernel source from: $$KERNEL_SOURCE_URL"
        KERNEL_PATH="kernel/$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        KERNEL_MANUFACTURER="$$(echo "$$KERNEL_PATH" | cut -d'/' -f2)"
        KERNEL_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        
        mkdir -p "kernel/$$KERNEL_MANUFACTURER"
        if ! git clone "$$KERNEL_SOURCE_URL" -b "$$KERNEL_SOURCE_BRANCH" "kernel/$$KERNEL_MANUFACTURER/$$KERNEL_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone kernel source, continuing without it"
        else
          echo "‚úÖ Kernel source cloned to kernel/$$KERNEL_MANUFACTURER/$$KERNEL_NAME"
        fi
      fi
      
      if [ -n "$$VENDOR_TREE_URL" ]; then
        echo "üè¢ Cloning vendor blobs from: $$VENDOR_TREE_URL"
        VENDOR_PATH="vendor/$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        VENDOR_MANUFACTURER="$$(echo "$$VENDOR_PATH" | cut -d'/' -f2)"
        VENDOR_NAME="$$(echo "$$TARGET_DEVICE" | cut -d'_' -f2 | cut -d'-' -f1)"
        
        mkdir -p "vendor/$$VENDOR_MANUFACTURER"
        if ! git clone "$$VENDOR_TREE_URL" -b "$$VENDOR_TREE_BRANCH" "vendor/$$VENDOR_MANUFACTURER/$$VENDOR_NAME" 2>&1 | tee -a "$$SYNC_LOG"; then
          echo "‚ö†Ô∏è Warning: Failed to clone vendor tree, continuing without it"
        else
          echo "‚úÖ Vendor blobs cloned to vendor/$$VENDOR_MANUFACTURER/$$VENDOR_NAME"
        fi
      fi
      
      # Upload artifacts
      cd ..
      buildkite-agent artifact upload "$$SYNC_LOG"
      buildkite-agent artifact upload "logs/sync-analytics.json"
    agents:
      queue: "default"
    timeout_in_minutes: 180
    retry:
      automatic:
        - exit_status: 1
          limit: 3
        - exit_status: 124
          limit: 3
    artifact_paths:
      - "logs/sync-*.log"
      - "logs/sync-analytics.json"
    concurrency_group: "source-sync"
    concurrency: 2

  - wait: ~
    continue_on_failure: false

  - label: ":building_construction: Enterprise Android ROM Build"
    key: "android-build"
    depends_on: "source-sync"
    command: |
      set -euo pipefail
      
      echo "üöÄ Enterprise Android ROM Build System Initiated"
      
      cd android-workspace
      
      # Enterprise build monitoring initialization
      BUILD_START=$$(date +%s)
      BUILD_ID="build-$$(date +%Y%m%d-%H%M%S)"
      BUILD_LOG="../logs/$$BUILD_ID.log"
      
      {
        echo "=== ENTERPRISE ANDROID ROM BUILD ==="
        echo "Build ID: $$BUILD_ID"
        echo "Started: $$(date -Iseconds)"
        echo "Target Device: $$TARGET_DEVICE"
        echo "Build Variant: $$BUILD_VARIANT"
        echo "Build Type: $$BUILD_TYPE"
        echo "Clean Build: $$CLEAN_BUILD"
        echo ""
      } > "$$BUILD_LOG"
      
      # Advanced resource monitoring function
      monitor_resources() {
        while true; do
          {
            echo "RESOURCE_SNAPSHOT: $$(date +%s)"
            echo "CPU_USAGE: $$(top -bn1 | grep "Cpu(s)" | awk '{print $$2}' | cut -d'%' -f1)"
            echo "MEMORY_USAGE: $$(free | awk '/^Mem:/ {printf "%.1f", ($$3/$$2)*100}')"
            echo "DISK_USAGE: $$(df -h . | awk 'NR==2 {print $$5}' | cut -d'%' -f1)"
            echo "CCACHE_STATS: $$(ccache -s | grep 'cache hit rate' | awk '{print $$4}')"
            echo "LOAD_AVERAGE: $$(uptime | awk -F'load average:' '{print $$2}' | awk '{print $$1}' | tr -d ',')"
          } >> "../logs/resource-usage-$$BUILD_ID.log"
          sleep 60
        done &
        MONITOR_PID=$$!
        echo "üìä Resource monitoring started (PID: $$MONITOR_PID)"
      }
      
      # Intelligent build job calculation
      calculate_build_jobs() {
        local cores=$$(nproc)
        local ram_gb=$$(free -g | awk '/^Mem:/ {print $$2}')
        local jobs
        
        if [ -n "$$BUILD_JOBS" ]; then
          jobs="$$BUILD_JOBS"
          echo "üîß Using specified build jobs: $$jobs"
        else
          # Calculate optimal jobs based on resources
          if [ "$$ram_gb" -ge 64 ]; then
            jobs=$$((cores * 2))
          elif [ "$$ram_gb" -ge 32 ]; then
            jobs=$$cores
          elif [ "$$ram_gb" -ge 16 ]; then
            jobs=$$((cores / 2))
          else
            jobs=$$((cores / 4))
          fi
          
          # Cap at reasonable limits
          if [ "$$jobs" -gt 32 ]; then
            jobs=32
          elif [ "$$jobs" -lt 1 ]; then
            jobs=1
          fi
          
          echo "üßÆ Calculated optimal build jobs: $$jobs ($$cores cores, $${ram_gb}GB RAM)"
        fi
        
        echo "$$jobs"
      }
      
      # Start resource monitoring
      monitor_resources
      
      # Calculate build jobs
      BUILD_JOBS_CALCULATED=$$(calculate_build_jobs)
      
      # Set up build environment
      echo "üîß Configuring enterprise build environment..."
      
      # Export Android build environment
      export USE_CCACHE=1
      export CCACHE_DIR="$$HOME/.ccache"
      export ANDROID_JACK_VM_ARGS="-Xmx4g -Dfile.encoding=UTF-8 -XX:+TieredCompilation"
      export JACK_SERVER_VM_ARGUMENTS="-Xmx4g -Dfile.encoding=UTF-8 -XX:+TieredCompilation"
      
      # Configure Java environment
      export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64
      export PATH=$$JAVA_HOME/bin:$$PATH
      
      # Advanced build optimization
      if [ "$$ram_gb" -ge 32 ]; then
        export ANDROID_COMPILE_WITH_JACK=true
        export DEFAULT_JACK_EXTRA_ARGS="--multi-dex=native"
      fi
      
      # Clean build if requested
      if [ "$$CLEAN_BUILD" = "true" ]; then
        echo "üßπ Performing clean build..."
        if [ -d "out" ]; then
          rm -rf out
        fi
        make clean 2>/dev/null || true
        ccache -C
      fi
      
      # Source build environment
      echo "üìã Sourcing build environment..."
      source build/envsetup.sh
      
      # Device configuration and validation
      echo "üîç Configuring target device: $$TARGET_DEVICE"
      
      if ! lunch "$$TARGET_DEVICE" 2>&1 | tee -a "$$BUILD_LOG"; then
        echo "‚ùå Failed to configure device: $$TARGET_DEVICE"
        exit 1
      fi
      
      # Enterprise build execution with comprehensive monitoring
      echo "üèóÔ∏è Starting enterprise ROM build..."
      
      {
        echo "=== BUILD EXECUTION ==="
        echo "Build Jobs: $$BUILD_JOBS_CALCULATED"
        echo "Ccache Size: $$(ccache -s | head -1)"
        echo "Java Version: $$(java -version 2>&1 | head -1)"
        echo "Build Command: make -j$$BUILD_JOBS_CALCULATED bacon"
        echo "Started: $$(date -Iseconds)"
      } | tee -a "$$BUILD_LOG"
      
      # Execute build with comprehensive error handling
      if ! make -j"$$BUILD_JOBS_CALCULATED" bacon 2>&1 | tee -a "$$BUILD_LOG"; then
        BUILD_EXIT_CODE=$$?
        echo "‚ùå Build failed with exit code: $$BUILD_EXIT_CODE"
        
        # Kill monitoring process
        if [ -n "$${MONITOR_PID:-}" ]; then
          kill "$$MONITOR_PID" 2>/dev/null || true
        fi
        
        # Comprehensive build failure analysis
        echo "üîç Analyzing build failure..."
        
        # Check for common failure patterns
        if grep -q "FAILED.*ninja" "$$BUILD_LOG"; then
          echo "üí• Ninja build system failure detected"
          echo "üîß Recommendation: Check for missing dependencies or corrupted source"
        elif grep -q "out of memory\|Cannot allocate memory" "$$BUILD_LOG"; then
          echo "üí• Out of memory error detected"
          echo "üîß Recommendation: Reduce build jobs or increase system memory"
        elif grep -q "No space left on device" "$$BUILD_LOG"; then
          echo "üí• Disk space exhausted"
          echo "üîß Recommendation: Clean build directory or expand storage"
        elif grep -q "fatal.*killed" "$$BUILD_LOG"; then
          echo "üí• Build process was killed (likely OOM)"
          echo "üîß Recommendation: Reduce concurrent jobs and enable swap"
        fi
        
        # Generate failure report
        {
          echo "{"
          echo "  \"timestamp\": \"$$(date -Iseconds)\","
          echo "  \"build_id\": \"$$BUILD_ID\","
          echo "  \"exit_code\": $$BUILD_EXIT_CODE,"
          echo "  \"duration_seconds\": $$(($(date +%s) - BUILD_START)),"
          echo "  \"target_device\": \"$$TARGET_DEVICE\","
          echo "  \"build_jobs\": $$BUILD_JOBS_CALCULATED,"
          echo "  \"status\": \"failed\""
          echo "}"
        } > "../logs/build-failure-$$BUILD_ID.json"
        
        exit $$BUILD_EXIT_CODE
      fi
      
      # Kill monitoring process
      if [ -n "$${MONITOR_PID:-}" ]; then
        kill "$$MONITOR_PID" 2>/dev/null || true
      fi
      
      # Build success processing
      BUILD_END=$$(date +%s)
      BUILD_DURATION=$$((BUILD_END - BUILD_START))
      
      echo "‚úÖ Build completed successfully in $${BUILD_DURATION}s!"
      
      # Locate and process build artifacts
      echo "üì¶ Processing build artifacts..."
      
      DEVICE_OUT="out/target/product"
      if [ -d "$$DEVICE_OUT" ]; then
        DEVICE_DIR=$$(ls "$$DEVICE_OUT" | head -1)
        if [ -n "$$DEVICE_DIR" ]; then
          ARTIFACT_PATH="$$DEVICE_OUT/$$DEVICE_DIR"
          
          # Generate checksums for all artifacts
          echo "üîê Generating security checksums..."
          find "$$ARTIFACT_PATH" -name "*.zip" -o -name "*.img" | while read -r file; do
            if [ -f "$$file" ]; then
              md5sum "$$file" > "$${file}.md5"
              sha256sum "$$file" > "$${file}.sha256"
            fi
          done
          
          # Create build manifest
          {
            echo "=== BUILD MANIFEST ==="
            echo "Build ID: $$BUILD_ID"
            echo "Completed: $$(date -Iseconds)"
            echo "Duration: $${BUILD_DURATION}s"
            echo "Device: $$TARGET_DEVICE"
            echo "Artifacts:"
            find "$$ARTIFACT_PATH" -name "*.zip" -o -name "*.img" | while read -r file; do
              if [ -f "$$file" ]; then
                echo "  - $$(basename "$$file") ($$(stat -c%s "$$file" | numfmt --to=iec-i))"
              fi
            done
          } > "../logs/build-manifest-$$BUILD_ID.txt"
        fi
      fi
      
      # Generate comprehensive build analytics
      {
        echo "{"
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"build_id\": \"$$BUILD_ID\","
        echo "  \"duration_seconds\": $$BUILD_DURATION,"
        echo "  \"target_device\": \"$$TARGET_DEVICE\","
        echo "  \"build_variant\": \"$$BUILD_VARIANT\","
        echo "  \"build_jobs\": $$BUILD_JOBS_CALCULATED,"
        echo "  \"ccache_hit_rate\": \"$$(ccache -s | grep 'cache hit rate' | awk '{print $$4}' || echo 'N/A')\","
        echo "  \"total_size_mb\": $$(du -sm out 2>/dev/null | cut -f1 || echo 0),"
        echo "  \"status\": \"success\""
        echo "}"
      } > "../logs/build-analytics-$$BUILD_ID.json"
      
      echo "‚úÖ Enterprise Android ROM build completed successfully!"
      
      # Upload artifacts
      cd ..
      buildkite-agent artifact upload "$$BUILD_LOG"
      buildkite-agent artifact upload "logs/build-analytics-$$BUILD_ID.json"
      buildkite-agent artifact upload "logs/resource-usage-$$BUILD_ID.log"
      buildkite-agent artifact upload "logs/build-manifest-$$BUILD_ID.txt"
      
      # Upload ROM artifacts if they exist
      if [ -d "android-workspace/out/target/product" ]; then
        find android-workspace/out/target/product -name "*.zip" -o -name "*.img" -o -name "*.md5" -o -name "*.sha256" | while read -r file; do
          if [ -f "$$file" ]; then
            buildkite-agent artifact upload "$$file"
          fi
        done
      fi
    agents:
      queue: "default"
    timeout_in_minutes: 300
    retry:
      automatic:
        - exit_status: 130
          limit: 2
        - exit_status: 137
          limit: 2
    artifact_paths:
      - "logs/build-*.log"
      - "logs/build-analytics-*.json"
      - "logs/resource-usage-*.log"
      - "logs/build-manifest-*.txt"
      - "android-workspace/out/target/product/*/*.zip"
      - "android-workspace/out/target/product/*/*.img"
      - "android-workspace/out/target/product/*/*.md5"
      - "android-workspace/out/target/product/*/*.sha256"
    concurrency_group: "android-build"
    concurrency: 1

  - wait: ~
    continue_on_failure: false

  - label: ":bell: Enterprise Build Notifications & Analytics"
    key: "notifications"
    depends_on: "android-build"
    command: |
      set -euo pipefail
      
      echo "üìä Enterprise build analytics and notifications..."
      
      # Generate comprehensive build report
      BUILD_REPORT="logs/final-build-report-$$(date +%Y%m%d-%H%M%S).json"
      
      {
        echo "{"
        echo "  \"pipeline_version\": \"$$PIPELINE_VERSION\","
        echo "  \"timestamp\": \"$$(date -Iseconds)\","
        echo "  \"build_result\": \"$$BUILDKITE_BUILD_STATE\","
        echo "  \"target_device\": \"$$TARGET_DEVICE\","
        echo "  \"build_variant\": \"$$BUILD_VARIANT\","
        echo "  \"build_type\": \"$$BUILD_TYPE\","
        echo "  \"build_number\": \"$$BUILDKITE_BUILD_NUMBER\","
        echo "  \"commit_hash\": \"$$BUILDKITE_COMMIT\","
        echo "  \"branch\": \"$$BUILDKITE_BRANCH\","
        echo "  \"pipeline_slug\": \"$$BUILDKITE_PIPELINE_SLUG\","
        echo "  \"build_url\": \"$$BUILDKITE_BUILD_URL\","
        echo "  \"agent_name\": \"$$BUILDKITE_AGENT_NAME\""
        echo "}"
      } > "$$BUILD_REPORT"
      
      # Send Slack notification if webhook is configured
      if [ -n "$${SLACK_WEBHOOK:-}" ]; then
        echo "üì± Sending Slack notification..."
        
        if [ "$$BUILDKITE_BUILD_STATE" = "passed" ]; then
          STATUS_EMOJI="‚úÖ"
          STATUS_COLOR="good"
          STATUS_TEXT="SUCCESS"
        else
          STATUS_EMOJI="‚ùå"
          STATUS_COLOR="danger"
          STATUS_TEXT="FAILED"
        fi
        
        curl -X POST "$$SLACK_WEBHOOK" \
          -H 'Content-type: application/json' \
          --data "{
            \"username\": \"Buildkite Android ROM Builder\",
            \"icon_emoji\": \":robot_face:\",
            \"attachments\": [
              {
                \"color\": \"$$STATUS_COLOR\",
                \"title\": \"$$STATUS_EMOJI Android ROM Build $$STATUS_TEXT\",
                \"fields\": [
                  {
                    \"title\": \"Device\",
                    \"value\": \"$$TARGET_DEVICE\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Build #\",
                    \"value\": \"$$BUILDKITE_BUILD_NUMBER\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Branch\",
                    \"value\": \"$$BUILDKITE_BRANCH\",
                    \"short\": true
                  },
                  {
                    \"title\": \"Agent\",
                    \"value\": \"$$BUILDKITE_AGENT_NAME\",
                    \"short\": true
                  }
                ],
                \"actions\": [
                  {
                    \"type\": \"button\",
                    \"text\": \"View Build\",
                    \"url\": \"$$BUILDKITE_BUILD_URL\"
                  }
                ]
              }
            ]
          }" || echo "‚ö†Ô∏è Failed to send Slack notification"
      fi
      
      # Print build summary
      echo ""
      echo "üéØ ===== ENTERPRISE BUILD SUMMARY ====="
      echo "üì± Device: $$TARGET_DEVICE"
      echo "üèóÔ∏è Build: #$$BUILDKITE_BUILD_NUMBER"
      echo "üåü Status: $$BUILDKITE_BUILD_STATE"
      echo "üöÄ Pipeline: $$PIPELINE_VERSION"
      echo "üîó URL: $$BUILDKITE_BUILD_URL"
      echo "‚è∞ Completed: $$(date)"
      echo "=================================="
      echo ""
      
      if [ "$$BUILDKITE_BUILD_STATE" = "passed" ]; then
        echo "üéâ Congratulations! Your Android ROM has been built successfully!"
        echo "üì¶ Check the artifacts section for your ROM files and installation instructions."
        echo "üîê All files include MD5 and SHA256 checksums for verification."
      else
        echo "üí• Build failed. Check the logs for detailed error information."
        echo "üîç Common solutions:"
        echo "   ‚Ä¢ Increase system memory if out-of-memory errors occurred"
        echo "   ‚Ä¢ Clean build directory if disk space issues"
        echo "   ‚Ä¢ Check network connectivity for source sync issues"
        echo "   ‚Ä¢ Verify target device configuration"
      fi
      
      # Upload final report
      buildkite-agent artifact upload "$$BUILD_REPORT"
      
      echo "‚úÖ Enterprise build process completed!"
    agents:
      queue: "default"
    timeout_in_minutes: 5
    artifact_paths:
      - "logs/final-build-report-*.json" 